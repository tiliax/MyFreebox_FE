{"ast":null,"code":"/* esri-leaflet-geocoder - v3.1.3 - Fri Apr 08 2022 10:06:56 GMT-0500 (Central Daylight Time)\n * Copyright (c) 2022 Environmental Systems Research Institute, Inc.\n * Apache-2.0 */\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('leaflet'), require('esri-leaflet')) : typeof define === 'function' && define.amd ? define(['exports', 'leaflet', 'esri-leaflet'], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global.L = global.L || {}, global.L.esri = global.L.esri || {}, global.L.esri.Geocoding = {}), global.L, global.L.esri));\n})(this, function (exports, leaflet, esriLeaflet) {\n  'use strict';\n\n  var version = \"3.1.3\";\n  var WorldGeocodingServiceUrl = 'https://geocode-api.arcgis.com/arcgis/rest/services/World/GeocodeServer/';\n  var Geocode = esriLeaflet.Task.extend({\n    path: 'findAddressCandidates',\n    params: {\n      outSr: 4326,\n      forStorage: false,\n      outFields: '*',\n      maxLocations: 20\n    },\n    setters: {\n      address: 'address',\n      neighborhood: 'neighborhood',\n      city: 'city',\n      subregion: 'subregion',\n      region: 'region',\n      postal: 'postal',\n      country: 'country',\n      text: 'singleLine',\n      category: 'category',\n      token: 'token',\n      apikey: 'apikey',\n      key: 'magicKey',\n      fields: 'outFields',\n      forStorage: 'forStorage',\n      maxLocations: 'maxLocations',\n      // World Geocoding Service (only works with singleLine)\n      countries: 'sourceCountry'\n    },\n    initialize: function (options) {\n      options = options || {};\n      options.url = options.url || WorldGeocodingServiceUrl;\n      esriLeaflet.Task.prototype.initialize.call(this, options);\n    },\n    within: function (bounds) {\n      bounds = leaflet.latLngBounds(bounds);\n      this.params.searchExtent = esriLeaflet.Util.boundsToExtent(bounds);\n      return this;\n    },\n    nearby: function (coords, radius) {\n      var centroid = leaflet.latLng(coords);\n      this.params.location = centroid.lng + ',' + centroid.lat;\n\n      if (radius) {\n        this.params.distance = Math.min(Math.max(radius, 2000), 50000);\n      }\n\n      return this;\n    },\n    run: function (callback, context) {\n      if (this.options.token) {\n        this.params.token = this.options.token;\n      }\n\n      if (this.options.apikey) {\n        this.params.token = this.options.apikey;\n      }\n\n      if (this.options.customParam) {\n        this.params[this.options.customParam] = this.params.singleLine;\n        delete this.params.singleLine;\n      }\n\n      return this.request(function (error, response) {\n        var processor = this._processGeocoderResponse;\n        var results = !error ? processor(response) : undefined;\n        callback.call(context, error, {\n          results: results\n        }, response);\n      }, this);\n    },\n    _processGeocoderResponse: function (response) {\n      var results = [];\n\n      for (var i = 0; i < response.candidates.length; i++) {\n        var candidate = response.candidates[i];\n\n        if (candidate.extent) {\n          var bounds = esriLeaflet.Util.extentToBounds(candidate.extent);\n        }\n\n        results.push({\n          text: candidate.address,\n          bounds: bounds,\n          score: candidate.score,\n          latlng: leaflet.latLng(candidate.location.y, candidate.location.x),\n          properties: candidate.attributes\n        });\n      }\n\n      return results;\n    }\n  });\n\n  function geocode(options) {\n    return new Geocode(options);\n  }\n\n  var ReverseGeocode = esriLeaflet.Task.extend({\n    path: 'reverseGeocode',\n    params: {\n      outSR: 4326,\n      returnIntersection: false\n    },\n    setters: {\n      distance: 'distance',\n      language: 'langCode',\n      intersection: 'returnIntersection',\n      apikey: 'apikey'\n    },\n    initialize: function (options) {\n      options = options || {};\n      options.url = options.url || WorldGeocodingServiceUrl;\n      esriLeaflet.Task.prototype.initialize.call(this, options);\n    },\n    latlng: function (coords) {\n      var centroid = leaflet.latLng(coords);\n      this.params.location = centroid.lng + ',' + centroid.lat;\n      return this;\n    },\n    run: function (callback, context) {\n      if (this.options.token) {\n        this.params.token = this.options.token;\n      }\n\n      if (this.options.apikey) {\n        this.params.token = this.options.apikey;\n      }\n\n      return this.request(function (error, response) {\n        var result;\n\n        if (!error) {\n          result = {\n            latlng: leaflet.latLng(response.location.y, response.location.x),\n            address: response.address\n          };\n        } else {\n          result = undefined;\n        }\n\n        callback.call(context, error, result, response);\n      }, this);\n    }\n  });\n\n  function reverseGeocode(options) {\n    return new ReverseGeocode(options);\n  }\n\n  var Suggest = esriLeaflet.Task.extend({\n    path: 'suggest',\n    params: {},\n    setters: {\n      text: 'text',\n      category: 'category',\n      countries: 'countryCode',\n      maxSuggestions: 'maxSuggestions'\n    },\n    initialize: function (options) {\n      options = options || {};\n\n      if (!options.url) {\n        options.url = WorldGeocodingServiceUrl;\n        options.supportsSuggest = true;\n      }\n\n      esriLeaflet.Task.prototype.initialize.call(this, options);\n    },\n    within: function (bounds) {\n      bounds = leaflet.latLngBounds(bounds);\n      var center = bounds.getCenter();\n      var ne = bounds.getNorthWest();\n      this.params.location = center.lng + ',' + center.lat;\n      this.params.distance = Math.min(Math.max(center.distanceTo(ne), 2000), 50000);\n      this.params.searchExtent = esriLeaflet.Util.boundsToExtent(bounds);\n      return this;\n    },\n    nearby: function (coords, radius) {\n      var centroid = leaflet.latLng(coords);\n      this.params.location = centroid.lng + ',' + centroid.lat;\n\n      if (radius) {\n        this.params.distance = Math.min(Math.max(radius, 2000), 50000);\n      }\n\n      return this;\n    },\n    run: function (callback, context) {\n      if (this.options.supportsSuggest) {\n        return this.request(function (error, response) {\n          callback.call(context, error, response, response);\n        }, this);\n      } else {\n        console.warn('this geocoding service does not support asking for suggestions');\n      }\n    }\n  });\n\n  function suggest(options) {\n    return new Suggest(options);\n  }\n\n  var GeocodeService = esriLeaflet.Service.extend({\n    initialize: function (options) {\n      options = options || {};\n\n      if (options.apikey) {\n        options.token = options.apikey;\n      }\n\n      if (options.url) {\n        esriLeaflet.Service.prototype.initialize.call(this, options);\n\n        this._confirmSuggestSupport();\n      } else {\n        options.url = WorldGeocodingServiceUrl;\n        options.supportsSuggest = true;\n        esriLeaflet.Service.prototype.initialize.call(this, options);\n      }\n    },\n    geocode: function () {\n      return geocode(this);\n    },\n    reverse: function () {\n      return reverseGeocode(this);\n    },\n    suggest: function () {\n      // requires either the Esri World Geocoding Service or a <10.3 ArcGIS Server Geocoding Service that supports suggest.\n      return suggest(this);\n    },\n    _confirmSuggestSupport: function () {\n      this.metadata(function (error, response) {\n        if (error) {\n          return;\n        } // pre 10.3 geocoding services dont list capabilities (and dont support maxLocations)\n        // only SOME individual services have been configured to support asking for suggestions\n\n\n        if (!response.capabilities) {\n          this.options.supportsSuggest = false;\n        } else if (response.capabilities.indexOf('Suggest') > -1) {\n          this.options.supportsSuggest = true;\n        } else {\n          this.options.supportsSuggest = false;\n        } // whether the service supports suggest or not, utilize the metadata response to determine the appropriate parameter name for single line geocoding requests\n\n\n        this.options.customParam = response.singleLineAddressField.name;\n      }, this);\n    }\n  });\n\n  function geocodeService(options) {\n    return new GeocodeService(options);\n  }\n\n  var GeosearchCore = leaflet.Evented.extend({\n    options: {\n      zoomToResult: true,\n      useMapBounds: 12,\n      searchBounds: null\n    },\n    initialize: function (control, options) {\n      leaflet.Util.setOptions(this, options);\n      this._control = control;\n\n      if (!options || !options.providers || !options.providers.length) {\n        throw new Error('You must specify at least one provider');\n      }\n\n      this._providers = options.providers;\n    },\n    _geocode: function (text, key, provider) {\n      var activeRequests = 0;\n      var allResults = [];\n      var bounds;\n      var callback = leaflet.Util.bind(function (error, results) {\n        activeRequests--;\n\n        if (error) {\n          return;\n        }\n\n        if (results) {\n          allResults = allResults.concat(results);\n        }\n\n        if (activeRequests <= 0) {\n          bounds = this._boundsFromResults(allResults);\n          this.fire('results', {\n            results: allResults,\n            bounds: bounds,\n            latlng: bounds ? bounds.getCenter() : undefined,\n            text: text\n          }, true);\n\n          if (this.options.zoomToResult && bounds) {\n            this._control._map.fitBounds(bounds);\n          }\n\n          this.fire('load');\n        }\n      }, this);\n\n      if (key) {\n        activeRequests++;\n        provider.results(text, key, this._searchBounds(), callback);\n      } else {\n        for (var i = 0; i < this._providers.length; i++) {\n          activeRequests++;\n\n          this._providers[i].results(text, key, this._searchBounds(), callback);\n        }\n      }\n    },\n    _suggest: function (text) {\n      var activeRequests = this._providers.length;\n      var suggestionsLength = 0;\n      var createCallback = leaflet.Util.bind(function (text, provider) {\n        return leaflet.Util.bind(function (error, suggestions) {\n          activeRequests = activeRequests - 1;\n          suggestionsLength += suggestions.length;\n\n          if (error) {\n            // an error occurred for one of the providers' suggest requests\n            this._control._clearProviderSuggestions(provider); // perform additional cleanup when all requests are finished\n\n\n            this._control._finalizeSuggestions(activeRequests, suggestionsLength);\n\n            return;\n          }\n\n          if (suggestions.length) {\n            for (var i = 0; i < suggestions.length; i++) {\n              suggestions[i].provider = provider;\n            }\n          } else {\n            // we still need to update the UI\n            this._control._renderSuggestions(suggestions);\n          }\n\n          if (provider._lastRender !== text) {\n            this._control._clearProviderSuggestions(provider);\n          }\n\n          if (suggestions.length && this._control._input.value === text) {\n            provider._lastRender = text;\n\n            this._control._renderSuggestions(suggestions);\n          } // perform additional cleanup when all requests are finished\n\n\n          this._control._finalizeSuggestions(activeRequests, suggestionsLength);\n        }, this);\n      }, this);\n      this._pendingSuggestions = [];\n\n      for (var i = 0; i < this._providers.length; i++) {\n        var provider = this._providers[i];\n        var request = provider.suggestions(text, this._searchBounds(), createCallback(text, provider));\n\n        this._pendingSuggestions.push(request);\n      }\n    },\n    _searchBounds: function () {\n      if (this.options.searchBounds !== null) {\n        return this.options.searchBounds;\n      }\n\n      if (this.options.useMapBounds === false) {\n        return null;\n      }\n\n      if (this.options.useMapBounds === true) {\n        return this._control._map.getBounds();\n      }\n\n      if (this.options.useMapBounds <= this._control._map.getZoom()) {\n        return this._control._map.getBounds();\n      }\n\n      return null;\n    },\n    _boundsFromResults: function (results) {\n      if (!results.length) {\n        return;\n      }\n\n      var nullIsland = leaflet.latLngBounds([0, 0], [0, 0]);\n      var resultBounds = [];\n      var resultLatlngs = []; // collect the bounds and center of each result\n\n      for (var i = results.length - 1; i >= 0; i--) {\n        var result = results[i];\n        resultLatlngs.push(result.latlng); // make sure bounds are valid and not 0,0. sometimes bounds are incorrect or not present\n\n        if (result.bounds && result.bounds.isValid() && !result.bounds.equals(nullIsland)) {\n          resultBounds.push(result.bounds);\n        }\n      } // form a bounds object containing all center points\n\n\n      var bounds = leaflet.latLngBounds(resultLatlngs); // and extend it to contain all bounds objects\n\n      for (var j = 0; j < resultBounds.length; j++) {\n        bounds.extend(resultBounds[j]);\n      }\n\n      return bounds;\n    },\n    _getAttribution: function () {\n      var attribs = [];\n      var providers = this._providers;\n\n      for (var i = 0; i < providers.length; i++) {\n        if (providers[i].options.attribution) {\n          attribs.push(providers[i].options.attribution);\n        }\n      }\n\n      return attribs.join(', ');\n    }\n  });\n\n  function geosearchCore(control, options) {\n    return new GeosearchCore(control, options);\n  }\n\n  var ArcgisOnlineProvider = GeocodeService.extend({\n    options: {\n      label: 'Places and Addresses',\n      maxResults: 5\n    },\n    suggestions: function (text, bounds, callback) {\n      var request = this.suggest().text(text);\n\n      if (bounds) {\n        request.within(bounds);\n      }\n\n      if (this.options.nearby) {\n        // \"distance\"/\"radius\" is not supported by the ArcGIS Online Geocoder,\n        // so that is intentionally not passed here:\n        request.nearby(this.options.nearby);\n      }\n\n      if (this.options.countries) {\n        request.countries(this.options.countries);\n      }\n\n      if (this.options.categories) {\n        request.category(this.options.categories);\n      } // 15 is the maximum number of suggestions that can be returned\n\n\n      request.maxSuggestions(this.options.maxResults);\n      return request.run(function (error, results, response) {\n        var suggestions = [];\n\n        if (!error) {\n          while (response.suggestions.length && suggestions.length <= this.options.maxResults - 1) {\n            var suggestion = response.suggestions.shift();\n\n            if (!suggestion.isCollection) {\n              suggestions.push({\n                text: suggestion.text,\n                unformattedText: suggestion.text,\n                magicKey: suggestion.magicKey\n              });\n            }\n          }\n        }\n\n        callback(error, suggestions);\n      }, this);\n    },\n    results: function (text, key, bounds, callback) {\n      var request = this.geocode().text(text);\n\n      if (key) {\n        request.key(key);\n      } // in the future Address/StreetName geocoding requests that include a magicKey will always only return one match\n\n\n      request.maxLocations(this.options.maxResults);\n\n      if (bounds) {\n        request.within(bounds);\n      }\n\n      if (this.options.forStorage) {\n        request.forStorage(true);\n      }\n\n      if (this.options.nearby) {\n        // \"distance\"/\"radius\" is not supported by the ArcGIS Online Geocoder,\n        // so that is intentionally not passed here:\n        request.nearby(this.options.nearby);\n      }\n\n      if (this.options.countries) {\n        request.countries(this.options.countries);\n      }\n\n      if (this.options.categories) {\n        request.category(this.options.categories);\n      }\n\n      return request.run(function (error, response) {\n        callback(error, response.results);\n      }, this);\n    }\n  });\n\n  function arcgisOnlineProvider(options) {\n    return new ArcgisOnlineProvider(options);\n  }\n\n  var Geosearch = leaflet.Control.extend({\n    includes: leaflet.Evented.prototype,\n    options: {\n      position: 'topleft',\n      collapseAfterResult: true,\n      expanded: false,\n      allowMultipleResults: true,\n      placeholder: 'Search for places or addresses',\n      title: 'Location Search'\n    },\n    initialize: function (options) {\n      leaflet.Util.setOptions(this, options);\n\n      if (!options || !options.providers || !options.providers.length) {\n        if (!options) {\n          options = {};\n        }\n\n        options.providers = [arcgisOnlineProvider()];\n      } // instantiate the underlying class and pass along options\n\n\n      this._geosearchCore = geosearchCore(this, options);\n      this._geosearchCore._providers = options.providers; // bubble each providers events to the control\n\n      this._geosearchCore.addEventParent(this);\n\n      for (var i = 0; i < this._geosearchCore._providers.length; i++) {\n        this._geosearchCore._providers[i].addEventParent(this);\n      }\n\n      this._geosearchCore._pendingSuggestions = [];\n      leaflet.Control.prototype.initialize.call(this, options);\n    },\n    _renderSuggestions: function (suggestions) {\n      var currentGroup;\n\n      if (suggestions.length > 0) {\n        this._suggestions.style.display = 'block';\n      }\n\n      var list;\n      var header;\n      var suggestionTextArray = [];\n\n      for (var i = 0; i < suggestions.length; i++) {\n        var suggestion = suggestions[i];\n\n        if (!header && this._geosearchCore._providers.length > 1 && currentGroup !== suggestion.provider.options.label) {\n          header = leaflet.DomUtil.create('div', 'geocoder-control-header', suggestion.provider._contentsElement);\n          header.textContent = suggestion.provider.options.label;\n          header.innerText = suggestion.provider.options.label;\n          currentGroup = suggestion.provider.options.label;\n        }\n\n        if (!list) {\n          list = leaflet.DomUtil.create('ul', 'geocoder-control-list', suggestion.provider._contentsElement);\n        }\n\n        if (suggestionTextArray.indexOf(suggestion.text) === -1) {\n          var suggestionItem = leaflet.DomUtil.create('li', 'geocoder-control-suggestion', list);\n          suggestionItem.innerHTML = suggestion.text;\n          suggestionItem.provider = suggestion.provider;\n          suggestionItem['data-magic-key'] = suggestion.magicKey;\n          suggestionItem.unformattedText = suggestion.unformattedText;\n        } else {\n          for (var j = 0; j < list.childNodes.length; j++) {\n            // if the same text already appears in the list of suggestions, append an additional ObjectID to its magicKey instead\n            if (list.childNodes[j].innerHTML === suggestion.text) {\n              list.childNodes[j]['data-magic-key'] += ',' + suggestion.magicKey;\n            }\n          }\n        }\n\n        suggestionTextArray.push(suggestion.text);\n      } // when the geocoder position is either \"topleft\" or \"topright\":\n      // set the maxHeight of the suggestions box to:\n      //  map height\n      //  - suggestions offset (distance from top of suggestions to top of control)\n      //  - control offset (distance from top of control to top of map)\n      //  - 10 (extra padding)\n\n\n      if (this.getPosition().indexOf('top') > -1) {\n        this._suggestions.style.maxHeight = this._map.getSize().y - this._suggestions.offsetTop - this._wrapper.offsetTop - 10 + 'px';\n      } // when the geocoder position is either \"bottomleft\" or \"bottomright\":\n      // 1. set the maxHeight of the suggestions box to:\n      //  map height\n      //  - corner control container offsetHeight (height of container of bottom corner)\n      //  - control offsetHeight (height of geocoder control wrapper, the main expandable button)\n      // 2. to move it up, set the top of the suggestions box to:\n      //  negative offsetHeight of suggestions box (its own negative height now that it has children elements\n      //  - control offsetHeight (height of geocoder control wrapper, the main expandable button)\n      //  + 20 (extra spacing)\n\n\n      if (this.getPosition().indexOf('bottom') > -1) {\n        this._setSuggestionsBottomPosition();\n      }\n    },\n    _setSuggestionsBottomPosition: function () {\n      this._suggestions.style.maxHeight = this._map.getSize().y - this._map._controlCorners[this.getPosition()].offsetHeight - this._wrapper.offsetHeight + 'px';\n      this._suggestions.style.top = -this._suggestions.offsetHeight - this._wrapper.offsetHeight + 20 + 'px';\n    },\n    _boundsFromResults: function (results) {\n      if (!results.length) {\n        return;\n      }\n\n      var nullIsland = leaflet.latLngBounds([0, 0], [0, 0]);\n      var resultBounds = [];\n      var resultLatlngs = []; // collect the bounds and center of each result\n\n      for (var i = results.length - 1; i >= 0; i--) {\n        var result = results[i];\n        resultLatlngs.push(result.latlng); // make sure bounds are valid and not 0,0. sometimes bounds are incorrect or not present\n\n        if (result.bounds && result.bounds.isValid() && !result.bounds.equals(nullIsland)) {\n          resultBounds.push(result.bounds);\n        }\n      } // form a bounds object containing all center points\n\n\n      var bounds = leaflet.latLngBounds(resultLatlngs); // and extend it to contain all bounds objects\n\n      for (var j = 0; j < resultBounds.length; j++) {\n        bounds.extend(resultBounds[j]);\n      }\n\n      return bounds;\n    },\n    clear: function () {\n      this._clearAllSuggestions();\n\n      if (this.options.collapseAfterResult) {\n        this._input.value = '';\n        this._lastValue = '';\n        this._input.placeholder = '';\n        leaflet.DomUtil.removeClass(this._wrapper, 'geocoder-control-expanded');\n      }\n\n      if (!this._map.scrollWheelZoom.enabled() && this._map.options.scrollWheelZoom) {\n        this._map.scrollWheelZoom.enable();\n      }\n    },\n    _clearAllSuggestions: function () {\n      this._suggestions.style.display = 'none';\n\n      for (var i = 0; i < this.options.providers.length; i++) {\n        this._clearProviderSuggestions(this.options.providers[i]);\n      }\n    },\n    _clearProviderSuggestions: function (provider) {\n      provider._contentsElement.innerHTML = '';\n    },\n    _finalizeSuggestions: function (activeRequests, suggestionsLength) {\n      // check if all requests are finished to remove the loading indicator\n      if (!activeRequests) {\n        leaflet.DomUtil.removeClass(this._input, 'geocoder-control-loading'); // when the geocoder position is either \"bottomleft\" or \"bottomright\",\n        // it is necessary in some cases to recalculate the maxHeight and top values of the this._suggestions element,\n        // even though this is also being done after each provider returns their own suggestions\n\n        if (this.getPosition().indexOf('bottom') > -1) {\n          this._setSuggestionsBottomPosition();\n        } // also check if there were 0 total suggest results to clear the parent suggestions element\n        // otherwise its display value may be \"block\" instead of \"none\"\n\n\n        if (!suggestionsLength) {\n          this._clearAllSuggestions();\n        }\n      }\n    },\n    _setupClick: function () {\n      leaflet.DomUtil.addClass(this._wrapper, 'geocoder-control-expanded');\n\n      this._input.focus();\n    },\n    disable: function () {\n      this._input.disabled = true;\n      leaflet.DomUtil.addClass(this._input, 'geocoder-control-input-disabled');\n      leaflet.DomEvent.removeListener(this._wrapper, 'click', this._setupClick, this);\n    },\n    enable: function () {\n      this._input.disabled = false;\n      leaflet.DomUtil.removeClass(this._input, 'geocoder-control-input-disabled');\n      leaflet.DomEvent.addListener(this._wrapper, 'click', this._setupClick, this);\n    },\n    getAttribution: function () {\n      var attribs = [];\n\n      for (var i = 0; i < this._providers.length; i++) {\n        if (this._providers[i].options.attribution) {\n          attribs.push(this._providers[i].options.attribution);\n        }\n      }\n\n      return attribs.join(', ');\n    },\n    geocodeSuggestion: function (e) {\n      var suggestionItem = e.target || e.srcElement;\n\n      if (suggestionItem.classList.contains('geocoder-control-suggestions') || suggestionItem.classList.contains('geocoder-control-header')) {\n        return;\n      } // make sure and point at the actual 'geocoder-control-suggestion'\n\n\n      if (suggestionItem.classList.length < 1) {\n        suggestionItem = suggestionItem.parentNode;\n      }\n\n      this._geosearchCore._geocode(suggestionItem.unformattedText, suggestionItem['data-magic-key'], suggestionItem.provider);\n\n      this.clear();\n    },\n    onAdd: function (map) {\n      // include 'Powered by Esri' in map attribution\n      esriLeaflet.Util.setEsriAttribution(map);\n      this._map = map;\n      this._wrapper = leaflet.DomUtil.create('div', 'geocoder-control');\n      this._input = leaflet.DomUtil.create('input', 'geocoder-control-input leaflet-bar', this._wrapper);\n      this._input.title = this.options.title;\n\n      if (this.options.expanded) {\n        leaflet.DomUtil.addClass(this._wrapper, 'geocoder-control-expanded');\n        this._input.placeholder = this.options.placeholder;\n      } // create the main suggested results container element\n\n\n      this._suggestions = leaflet.DomUtil.create('div', 'geocoder-control-suggestions leaflet-bar', this._wrapper); // create a child contents container element for each provider inside of this._suggestions\n      // to maintain the configured order of providers for suggested results\n\n      for (var i = 0; i < this.options.providers.length; i++) {\n        this.options.providers[i]._contentsElement = leaflet.DomUtil.create('div', null, this._suggestions);\n      }\n\n      var credits = this._geosearchCore._getAttribution();\n\n      if (map.attributionControl) {\n        map.attributionControl.addAttribution(credits);\n      }\n\n      leaflet.DomEvent.addListener(this._input, 'focus', function (e) {\n        this._input.placeholder = this.options.placeholder;\n        leaflet.DomUtil.addClass(this._wrapper, 'geocoder-control-expanded');\n      }, this);\n      leaflet.DomEvent.addListener(this._wrapper, 'click', this._setupClick, this); // make sure both click and touch spawn an address/poi search\n\n      leaflet.DomEvent.addListener(this._suggestions, 'mousedown', this.geocodeSuggestion, this);\n      leaflet.DomEvent.addListener(this._input, 'blur', function (e) {\n        // TODO: this is too greedy and should not \"clear\"\n        // when trying to use the scrollbar or clicking on a non-suggestion item (such as a provider header)\n        this.clear();\n      }, this);\n      leaflet.DomEvent.addListener(this._input, 'keydown', function (e) {\n        var text = (e.target || e.srcElement).value;\n        leaflet.DomUtil.addClass(this._wrapper, 'geocoder-control-expanded');\n\n        var list = this._suggestions.querySelectorAll('.' + 'geocoder-control-suggestion');\n\n        var selected = this._suggestions.querySelectorAll('.' + 'geocoder-control-selected')[0];\n\n        var selectedPosition;\n\n        for (var i = 0; i < list.length; i++) {\n          if (list[i] === selected) {\n            selectedPosition = i;\n            break;\n          }\n        }\n\n        switch (e.keyCode) {\n          case 13:\n            /*\r\n              if an item has been selected, geocode it\r\n              if focus is on the input textbox, geocode only if multiple results are allowed and more than two characters are present, or if a single suggestion is displayed.\r\n              if less than two characters have been typed, abort the geocode\r\n            */\n            if (selected) {\n              this._input.value = selected.innerText;\n\n              this._geosearchCore._geocode(selected.unformattedText, selected['data-magic-key'], selected.provider);\n\n              this.clear();\n            } else if (this.options.allowMultipleResults && text.length >= 2) {\n              this._geosearchCore._geocode(this._input.value, undefined);\n\n              this.clear();\n            } else {\n              if (list.length === 1) {\n                leaflet.DomUtil.addClass(list[0], 'geocoder-control-selected');\n\n                this._geosearchCore._geocode(list[0].innerHTML, list[0]['data-magic-key'], list[0].provider);\n              } else {\n                this.clear();\n\n                this._input.blur();\n              }\n            }\n\n            leaflet.DomEvent.preventDefault(e);\n            break;\n\n          case 38:\n            if (selected) {\n              leaflet.DomUtil.removeClass(selected, 'geocoder-control-selected');\n            }\n\n            var previousItem = list[selectedPosition - 1];\n\n            if (selected && previousItem) {\n              leaflet.DomUtil.addClass(previousItem, 'geocoder-control-selected');\n            } else {\n              leaflet.DomUtil.addClass(list[list.length - 1], 'geocoder-control-selected');\n            }\n\n            leaflet.DomEvent.preventDefault(e);\n            break;\n\n          case 40:\n            if (selected) {\n              leaflet.DomUtil.removeClass(selected, 'geocoder-control-selected');\n            }\n\n            var nextItem = list[selectedPosition + 1];\n\n            if (selected && nextItem) {\n              leaflet.DomUtil.addClass(nextItem, 'geocoder-control-selected');\n            } else {\n              leaflet.DomUtil.addClass(list[0], 'geocoder-control-selected');\n            }\n\n            leaflet.DomEvent.preventDefault(e);\n            break;\n\n          default:\n            // when the input changes we should cancel all pending suggestion requests if possible to avoid result collisions\n            for (var x = 0; x < this._geosearchCore._pendingSuggestions.length; x++) {\n              var request = this._geosearchCore._pendingSuggestions[x];\n\n              if (request && request.abort && !request.id) {\n                request.abort();\n              }\n            }\n\n            break;\n        }\n      }, this);\n      leaflet.DomEvent.addListener(this._input, 'keyup', leaflet.Util.throttle(function (e) {\n        var key = e.which || e.keyCode;\n        var text = (e.target || e.srcElement).value; // require at least 2 characters for suggestions\n\n        if (text.length < 2) {\n          this._lastValue = this._input.value;\n\n          this._clearAllSuggestions();\n\n          leaflet.DomUtil.removeClass(this._input, 'geocoder-control-loading');\n          return;\n        } // if this is the escape key it will clear the input so clear suggestions\n\n\n        if (key === 27) {\n          this._clearAllSuggestions();\n\n          return;\n        } // if this is NOT the up/down arrows or enter make a suggestion\n\n\n        if (key !== 13 && key !== 38 && key !== 40) {\n          if (this._input.value !== this._lastValue) {\n            this._lastValue = this._input.value;\n            leaflet.DomUtil.addClass(this._input, 'geocoder-control-loading');\n\n            this._geosearchCore._suggest(text);\n          }\n        }\n      }, 50, this), this);\n      leaflet.DomEvent.disableClickPropagation(this._wrapper); // when mouse moves over suggestions disable scroll wheel zoom if its enabled\n\n      leaflet.DomEvent.addListener(this._suggestions, 'mouseover', function (e) {\n        if (map.scrollWheelZoom.enabled() && map.options.scrollWheelZoom) {\n          map.scrollWheelZoom.disable();\n        }\n      }); // when mouse moves leaves suggestions enable scroll wheel zoom if its disabled\n\n      leaflet.DomEvent.addListener(this._suggestions, 'mouseout', function (e) {\n        if (!map.scrollWheelZoom.enabled() && map.options.scrollWheelZoom) {\n          map.scrollWheelZoom.enable();\n        }\n      });\n\n      this._geosearchCore.on('load', function (e) {\n        leaflet.DomUtil.removeClass(this._input, 'geocoder-control-loading');\n        this.clear();\n\n        this._input.blur();\n      }, this);\n\n      return this._wrapper;\n    }\n  });\n\n  function geosearch(options) {\n    return new Geosearch(options);\n  }\n\n  var FeatureLayerProvider = esriLeaflet.FeatureLayerService.extend({\n    options: {\n      label: 'Feature Layer',\n      maxResults: 5,\n      bufferRadius: 1000,\n      searchMode: 'contain',\n      formatSuggestion: function (feature) {\n        return feature.properties[this.options.searchFields[0]];\n      }\n    },\n    initialize: function (options) {\n      if (options.apikey) {\n        options.token = options.apikey;\n      }\n\n      esriLeaflet.FeatureLayerService.prototype.initialize.call(this, options);\n\n      if (typeof this.options.searchFields === 'string') {\n        this.options.searchFields = [this.options.searchFields];\n      }\n\n      this._suggestionsQuery = this.query();\n      this._resultsQuery = this.query();\n    },\n    suggestions: function (text, bounds, callback) {\n      var query = this._suggestionsQuery.where(this._buildQuery(text)).returnGeometry(false);\n\n      if (bounds) {\n        query.intersects(bounds);\n      }\n\n      if (this.options.idField) {\n        query.fields([this.options.idField].concat(this.options.searchFields));\n      }\n\n      var request = query.run(function (error, results, raw) {\n        if (error) {\n          callback(error, []);\n        } else {\n          this.options.idField = raw.objectIdFieldName;\n          var suggestions = [];\n\n          for (var i = results.features.length - 1; i >= 0; i--) {\n            var feature = results.features[i];\n            suggestions.push({\n              text: this.options.formatSuggestion.call(this, feature),\n              unformattedText: feature.properties[this.options.searchFields[0]],\n              magicKey: feature.id\n            });\n          }\n\n          callback(error, suggestions.slice(0, this.options.maxResults));\n        }\n      }, this);\n      return request;\n    },\n    results: function (text, key, bounds, callback) {\n      var query = this._resultsQuery;\n\n      if (key) {\n        // if there are 1 or more keys available, use query.featureIds()\n        delete query.params.where;\n        query.featureIds([key]);\n      } else {\n        // if there are no keys available, use query.where()\n        query.where(this._buildQuery(text));\n      }\n\n      if (bounds) {\n        query.within(bounds);\n      }\n\n      return query.run(leaflet.Util.bind(function (error, features) {\n        var results = [];\n\n        for (var i = 0; i < features.features.length; i++) {\n          var feature = features.features[i];\n\n          if (feature) {\n            var bounds = this._featureBounds(feature);\n\n            var result = {\n              latlng: bounds.getCenter(),\n              bounds: bounds,\n              text: this.options.formatSuggestion.call(this, feature),\n              properties: feature.properties,\n              geojson: feature\n            };\n            results.push(result); // clear query parameters for the next search\n\n            delete this._resultsQuery.params['objectIds'];\n          }\n        }\n\n        callback(error, results);\n      }, this));\n    },\n    orderBy: function (fieldName, order) {\n      this._suggestionsQuery.orderBy(fieldName, order);\n    },\n    _buildQuery: function (text) {\n      var queryString = [];\n\n      for (var i = this.options.searchFields.length - 1; i >= 0; i--) {\n        var field = 'upper(\"' + this.options.searchFields[i] + '\")';\n\n        if (this.options.searchMode === 'contain') {\n          queryString.push(field + \" LIKE upper('%\" + text + \"%')\");\n        } else if (this.options.searchMode === 'startWith') {\n          queryString.push(field + \" LIKE upper('\" + text + \"%')\");\n        } else if (this.options.searchMode === 'endWith') {\n          queryString.push(field + \" LIKE upper('%\" + text + \"')\");\n        } else if (this.options.searchMode === 'strict') {\n          queryString.push(field + \" LIKE upper('\" + text + \"')\");\n        } else {\n          throw new Error('L.esri.Geocoding.featureLayerProvider: Invalid parameter for \"searchMode\". Use one of \"contain\", \"startWith\", \"endWith\", or \"strict\"');\n        }\n      }\n\n      if (this.options.where) {\n        return this.options.where + ' AND (' + queryString.join(' OR ') + ')';\n      } else {\n        return queryString.join(' OR ');\n      }\n    },\n    _featureBounds: function (feature) {\n      var geojson = leaflet.geoJson(feature);\n\n      if (feature.geometry.type === 'Point') {\n        var center = geojson.getBounds().getCenter();\n        var lngRadius = this.options.bufferRadius / 40075017 * 360 / Math.cos(180 / Math.PI * center.lat);\n        var latRadius = this.options.bufferRadius / 40075017 * 360;\n        return leaflet.latLngBounds([center.lat - latRadius, center.lng - lngRadius], [center.lat + latRadius, center.lng + lngRadius]);\n      } else {\n        return geojson.getBounds();\n      }\n    }\n  });\n\n  function featureLayerProvider(options) {\n    return new FeatureLayerProvider(options);\n  }\n\n  var MapServiceProvider = esriLeaflet.MapService.extend({\n    options: {\n      layers: [0],\n      label: 'Map Service',\n      bufferRadius: 1000,\n      maxResults: 5,\n      formatSuggestion: function (feature) {\n        return feature.properties[feature.displayFieldName] + ' <small>' + feature.layerName + '</small>';\n      }\n    },\n    initialize: function (options) {\n      if (options.apikey) {\n        options.token = options.apikey;\n      }\n\n      esriLeaflet.MapService.prototype.initialize.call(this, options);\n\n      this._getIdFields();\n    },\n    suggestions: function (text, bounds, callback) {\n      var request = this.find().text(text).fields(this.options.searchFields).returnGeometry(false).layers(this.options.layers);\n      return request.run(function (error, results, raw) {\n        var suggestions = [];\n\n        if (!error) {\n          var count = Math.min(this.options.maxResults, results.features.length);\n          raw.results = raw.results.reverse();\n\n          for (var i = 0; i < count; i++) {\n            var feature = results.features[i];\n            var result = raw.results[i];\n            var layer = result.layerId;\n            var idField = this._idFields[layer];\n            feature.layerId = layer;\n            feature.layerName = this._layerNames[layer];\n            feature.displayFieldName = this._displayFields[layer];\n\n            if (idField) {\n              suggestions.push({\n                text: this.options.formatSuggestion.call(this, feature),\n                unformattedText: feature.properties[feature.displayFieldName],\n                magicKey: result.attributes[idField] + ':' + layer\n              });\n            }\n          }\n        }\n\n        callback(error, suggestions.reverse());\n      }, this);\n    },\n    results: function (text, key, bounds, callback) {\n      var results = [];\n      var request;\n\n      if (key && !key.includes(',')) {\n        // if there is only 1 key available, use query()\n        var featureId = key.split(':')[0];\n        var layer = key.split(':')[1];\n        request = this.query().layer(layer).featureIds(featureId);\n      } else {\n        // if there are no keys or more than 1 keys available, use find()\n        request = this.find().text(text).fields(this.options.searchFields).layers(this.options.layers);\n      }\n\n      return request.run(function (error, features, response) {\n        if (!error) {\n          if (response.results) {\n            response.results = response.results.reverse();\n          }\n\n          for (var i = 0; i < features.features.length; i++) {\n            var feature = features.features[i];\n            layer = layer || response.results[i].layerId;\n\n            if (feature && layer !== undefined) {\n              var bounds = this._featureBounds(feature);\n\n              feature.layerId = layer;\n              feature.layerName = this._layerNames[layer];\n              feature.displayFieldName = this._displayFields[layer];\n              var result = {\n                latlng: bounds.getCenter(),\n                bounds: bounds,\n                text: this.options.formatSuggestion.call(this, feature),\n                properties: feature.properties,\n                geojson: feature\n              };\n              results.push(result);\n            }\n          }\n        }\n\n        callback(error, results.reverse());\n      }, this);\n    },\n    _featureBounds: function (feature) {\n      var geojson = leaflet.geoJson(feature);\n\n      if (feature.geometry.type === 'Point') {\n        var center = geojson.getBounds().getCenter();\n        var lngRadius = this.options.bufferRadius / 40075017 * 360 / Math.cos(180 / Math.PI * center.lat);\n        var latRadius = this.options.bufferRadius / 40075017 * 360;\n        return leaflet.latLngBounds([center.lat - latRadius, center.lng - lngRadius], [center.lat + latRadius, center.lng + lngRadius]);\n      } else {\n        return geojson.getBounds();\n      }\n    },\n    _layerMetadataCallback: function (layerid) {\n      return leaflet.Util.bind(function (error, metadata) {\n        if (error) {\n          return;\n        }\n\n        this._displayFields[layerid] = metadata.displayField;\n        this._layerNames[layerid] = metadata.name;\n\n        for (var i = 0; i < metadata.fields.length; i++) {\n          var field = metadata.fields[i];\n\n          if (field.type === 'esriFieldTypeOID') {\n            this._idFields[layerid] = field.name;\n            break;\n          }\n        }\n      }, this);\n    },\n    _getIdFields: function () {\n      this._idFields = {};\n      this._displayFields = {};\n      this._layerNames = {};\n\n      for (var i = 0; i < this.options.layers.length; i++) {\n        var layer = this.options.layers[i];\n        this.get(layer, {}, this._layerMetadataCallback(layer));\n      }\n    }\n  });\n\n  function mapServiceProvider(options) {\n    return new MapServiceProvider(options);\n  }\n\n  var GeocodeServiceProvider = GeocodeService.extend({\n    options: {\n      label: 'Geocode Server',\n      maxResults: 5\n    },\n    suggestions: function (text, bounds, callback) {\n      if (this.options.supportsSuggest) {\n        var request = this.suggest().text(text);\n\n        if (bounds) {\n          request.within(bounds);\n        }\n\n        return request.run(function (error, results, response) {\n          var suggestions = [];\n\n          if (!error) {\n            while (response.suggestions.length && suggestions.length <= this.options.maxResults - 1) {\n              var suggestion = response.suggestions.shift();\n\n              if (!suggestion.isCollection) {\n                suggestions.push({\n                  text: suggestion.text,\n                  unformattedText: suggestion.text,\n                  magicKey: suggestion.magicKey\n                });\n              }\n            }\n          }\n\n          callback(error, suggestions);\n        }, this);\n      } else {\n        callback(null, []);\n        return false;\n      }\n    },\n    results: function (text, key, bounds, callback) {\n      var request = this.geocode().text(text);\n\n      if (key) {\n        request.key(key);\n      }\n\n      request.maxLocations(this.options.maxResults);\n\n      if (bounds) {\n        request.within(bounds);\n      }\n\n      return request.run(function (error, response) {\n        callback(error, response.results);\n      }, this);\n    }\n  });\n\n  function geocodeServiceProvider(options) {\n    return new GeocodeServiceProvider(options);\n  }\n\n  exports.ArcgisOnlineProvider = ArcgisOnlineProvider;\n  exports.FeatureLayerProvider = FeatureLayerProvider;\n  exports.Geocode = Geocode;\n  exports.GeocodeService = GeocodeService;\n  exports.GeocodeServiceProvider = GeocodeServiceProvider;\n  exports.Geosearch = Geosearch;\n  exports.GeosearchCore = GeosearchCore;\n  exports.MapServiceProvider = MapServiceProvider;\n  exports.ReverseGeocode = ReverseGeocode;\n  exports.Suggest = Suggest;\n  exports.VERSION = version;\n  exports.WorldGeocodingServiceUrl = WorldGeocodingServiceUrl;\n  exports.arcgisOnlineProvider = arcgisOnlineProvider;\n  exports.featureLayerProvider = featureLayerProvider;\n  exports.geocode = geocode;\n  exports.geocodeService = geocodeService;\n  exports.geocodeServiceProvider = geocodeServiceProvider;\n  exports.geosearch = geosearch;\n  exports.geosearchCore = geosearchCore;\n  exports.mapServiceProvider = mapServiceProvider;\n  exports.reverseGeocode = reverseGeocode;\n  exports.suggest = suggest;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":{"version":3,"mappings":"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","names":["WorldGeocodingServiceUrl","Geocode","Task","extend","path","params","outSr","forStorage","outFields","maxLocations","setters","address","neighborhood","city","subregion","region","postal","country","text","category","token","apikey","key","fields","countries","initialize","options","url","prototype","call","within","bounds","latLngBounds","searchExtent","EsriUtil","boundsToExtent","nearby","coords","radius","centroid","latLng","location","lng","lat","distance","Math","min","max","run","callback","context","customParam","singleLine","request","error","response","processor","_processGeocoderResponse","results","undefined","i","candidates","length","candidate","extent","extentToBounds","push","score","latlng","y","x","properties","attributes","geocode","ReverseGeocode","outSR","returnIntersection","language","intersection","result","reverseGeocode","Suggest","maxSuggestions","supportsSuggest","center","getCenter","ne","getNorthWest","distanceTo","console","warn","suggest","GeocodeService","Service","_confirmSuggestSupport","reverse","metadata","capabilities","indexOf","singleLineAddressField","name","geocodeService","GeosearchCore","Evented","zoomToResult","useMapBounds","searchBounds","control","Util","setOptions","_control","providers","Error","_providers","_geocode","provider","activeRequests","allResults","bind","concat","_boundsFromResults","fire","_map","fitBounds","_searchBounds","_suggest","suggestionsLength","createCallback","suggestions","_clearProviderSuggestions","_finalizeSuggestions","_renderSuggestions","_lastRender","_input","value","_pendingSuggestions","getBounds","getZoom","nullIsland","resultBounds","resultLatlngs","isValid","equals","j","_getAttribution","attribs","attribution","join","geosearchCore","ArcgisOnlineProvider","label","maxResults","categories","suggestion","shift","isCollection","unformattedText","magicKey","arcgisOnlineProvider","Geosearch","Control","includes","position","collapseAfterResult","expanded","allowMultipleResults","placeholder","title","_geosearchCore","addEventParent","currentGroup","_suggestions","style","display","list","header","suggestionTextArray","DomUtil","create","_contentsElement","textContent","innerText","suggestionItem","innerHTML","childNodes","getPosition","maxHeight","getSize","offsetTop","_wrapper","_setSuggestionsBottomPosition","_controlCorners","offsetHeight","top","clear","_clearAllSuggestions","_lastValue","removeClass","scrollWheelZoom","enabled","enable","_setupClick","addClass","focus","disable","disabled","DomEvent","removeListener","addListener","getAttribution","geocodeSuggestion","e","target","srcElement","classList","contains","parentNode","onAdd","map","setEsriAttribution","credits","attributionControl","addAttribution","querySelectorAll","selected","selectedPosition","keyCode","blur","preventDefault","previousItem","nextItem","abort","id","throttle","which","disableClickPropagation","on","geosearch","FeatureLayerProvider","FeatureLayerService","bufferRadius","searchMode","formatSuggestion","feature","searchFields","_suggestionsQuery","query","_resultsQuery","where","_buildQuery","returnGeometry","intersects","idField","raw","objectIdFieldName","features","slice","featureIds","_featureBounds","geojson","orderBy","fieldName","order","queryString","field","geoJson","geometry","type","lngRadius","cos","PI","latRadius","featureLayerProvider","MapServiceProvider","MapService","layers","displayFieldName","layerName","_getIdFields","find","count","layer","layerId","_idFields","_layerNames","_displayFields","featureId","split","_layerMetadataCallback","layerid","displayField","get","mapServiceProvider","GeocodeServiceProvider","geocodeServiceProvider"],"sources":["C:\\Users\\Larix\\Documents\\Programmieren\\ABSCHLUSS\\wbs-final-box-fe\\node_modules\\esri-leaflet-geocoder\\src\\helper.js","C:\\Users\\Larix\\Documents\\Programmieren\\ABSCHLUSS\\wbs-final-box-fe\\node_modules\\esri-leaflet-geocoder\\src\\Tasks\\Geocode.js","C:\\Users\\Larix\\Documents\\Programmieren\\ABSCHLUSS\\wbs-final-box-fe\\node_modules\\esri-leaflet-geocoder\\src\\Tasks\\ReverseGeocode.js","C:\\Users\\Larix\\Documents\\Programmieren\\ABSCHLUSS\\wbs-final-box-fe\\node_modules\\esri-leaflet-geocoder\\src\\Tasks\\Suggest.js","C:\\Users\\Larix\\Documents\\Programmieren\\ABSCHLUSS\\wbs-final-box-fe\\node_modules\\esri-leaflet-geocoder\\src\\Services\\Geocode.js","C:\\Users\\Larix\\Documents\\Programmieren\\ABSCHLUSS\\wbs-final-box-fe\\node_modules\\esri-leaflet-geocoder\\src\\Classes\\GeosearchCore.js","C:\\Users\\Larix\\Documents\\Programmieren\\ABSCHLUSS\\wbs-final-box-fe\\node_modules\\esri-leaflet-geocoder\\src\\Providers\\ArcgisOnlineGeocoder.js","C:\\Users\\Larix\\Documents\\Programmieren\\ABSCHLUSS\\wbs-final-box-fe\\node_modules\\esri-leaflet-geocoder\\src\\Controls\\Geosearch.js","C:\\Users\\Larix\\Documents\\Programmieren\\ABSCHLUSS\\wbs-final-box-fe\\node_modules\\esri-leaflet-geocoder\\src\\Providers\\FeatureLayer.js","C:\\Users\\Larix\\Documents\\Programmieren\\ABSCHLUSS\\wbs-final-box-fe\\node_modules\\esri-leaflet-geocoder\\src\\Providers\\MapService.js","C:\\Users\\Larix\\Documents\\Programmieren\\ABSCHLUSS\\wbs-final-box-fe\\node_modules\\esri-leaflet-geocoder\\src\\Providers\\GeocodeService.js"],"sourcesContent":["export var WorldGeocodingServiceUrl = 'https://geocode-api.arcgis.com/arcgis/rest/services/World/GeocodeServer/';\r\n","import {\r\n  latLng,\r\n  latLngBounds\r\n} from 'leaflet';\r\nimport { Task, Util as EsriUtil } from 'esri-leaflet';\r\nimport { WorldGeocodingServiceUrl } from '../helper';\r\n\r\nexport var Geocode = Task.extend({\r\n  path: 'findAddressCandidates',\r\n\r\n  params: {\r\n    outSr: 4326,\r\n    forStorage: false,\r\n    outFields: '*',\r\n    maxLocations: 20\r\n  },\r\n\r\n  setters: {\r\n    address: 'address',\r\n    neighborhood: 'neighborhood',\r\n    city: 'city',\r\n    subregion: 'subregion',\r\n    region: 'region',\r\n    postal: 'postal',\r\n    country: 'country',\r\n    text: 'singleLine',\r\n    category: 'category',\r\n    token: 'token',\r\n    apikey: 'apikey',\r\n    key: 'magicKey',\r\n    fields: 'outFields',\r\n    forStorage: 'forStorage',\r\n    maxLocations: 'maxLocations',\r\n    // World Geocoding Service (only works with singleLine)\r\n    countries: 'sourceCountry'\r\n  },\r\n\r\n  initialize: function (options) {\r\n    options = options || {};\r\n    options.url = options.url || WorldGeocodingServiceUrl;\r\n    Task.prototype.initialize.call(this, options);\r\n  },\r\n\r\n  within: function (bounds) {\r\n    bounds = latLngBounds(bounds);\r\n    this.params.searchExtent = EsriUtil.boundsToExtent(bounds);\r\n    return this;\r\n  },\r\n\r\n  nearby: function (coords, radius) {\r\n    var centroid = latLng(coords);\r\n    this.params.location = centroid.lng + ',' + centroid.lat;\r\n    if (radius) {\r\n      this.params.distance = Math.min(Math.max(radius, 2000), 50000);\r\n    }\r\n    return this;\r\n  },\r\n\r\n  run: function (callback, context) {\r\n    if (this.options.token) {\r\n      this.params.token = this.options.token;\r\n    }\r\n    if (this.options.apikey) {\r\n      this.params.token = this.options.apikey;\r\n    }\r\n    if (this.options.customParam) {\r\n      this.params[this.options.customParam] = this.params.singleLine;\r\n      delete this.params.singleLine;\r\n    }\r\n\r\n    return this.request(function (error, response) {\r\n      var processor = this._processGeocoderResponse;\r\n      var results = (!error) ? processor(response) : undefined;\r\n      callback.call(context, error, { results: results }, response);\r\n    }, this);\r\n  },\r\n\r\n  _processGeocoderResponse: function (response) {\r\n    var results = [];\r\n\r\n    for (var i = 0; i < response.candidates.length; i++) {\r\n      var candidate = response.candidates[i];\r\n      if (candidate.extent) {\r\n        var bounds = EsriUtil.extentToBounds(candidate.extent);\r\n      }\r\n\r\n      results.push({\r\n        text: candidate.address,\r\n        bounds: bounds,\r\n        score: candidate.score,\r\n        latlng: latLng(candidate.location.y, candidate.location.x),\r\n        properties: candidate.attributes\r\n      });\r\n    }\r\n    return results;\r\n  }\r\n});\r\n\r\nexport function geocode (options) {\r\n  return new Geocode(options);\r\n}\r\n\r\nexport default geocode;\r\n","import { latLng } from 'leaflet';\r\nimport { Task } from 'esri-leaflet';\r\nimport { WorldGeocodingServiceUrl } from '../helper';\r\n\r\nexport var ReverseGeocode = Task.extend({\r\n  path: 'reverseGeocode',\r\n\r\n  params: {\r\n    outSR: 4326,\r\n    returnIntersection: false\r\n  },\r\n\r\n  setters: {\r\n    distance: 'distance',\r\n    language: 'langCode',\r\n    intersection: 'returnIntersection',\r\n    apikey: 'apikey'\r\n  },\r\n\r\n  initialize: function (options) {\r\n    options = options || {};\r\n    options.url = options.url || WorldGeocodingServiceUrl;\r\n    Task.prototype.initialize.call(this, options);\r\n  },\r\n\r\n  latlng: function (coords) {\r\n    var centroid = latLng(coords);\r\n    this.params.location = centroid.lng + ',' + centroid.lat;\r\n    return this;\r\n  },\r\n\r\n  run: function (callback, context) {\r\n    if (this.options.token) {\r\n      this.params.token = this.options.token;\r\n    }\r\n    if (this.options.apikey) {\r\n      this.params.token = this.options.apikey;\r\n    }\r\n    return this.request(function (error, response) {\r\n      var result;\r\n\r\n      if (!error) {\r\n        result = {\r\n          latlng: latLng(response.location.y, response.location.x),\r\n          address: response.address\r\n        };\r\n      } else {\r\n        result = undefined;\r\n      }\r\n\r\n      callback.call(context, error, result, response);\r\n    }, this);\r\n  }\r\n});\r\n\r\nexport function reverseGeocode (options) {\r\n  return new ReverseGeocode(options);\r\n}\r\n\r\nexport default reverseGeocode;\r\n","import {\r\n  latLng,\r\n  latLngBounds\r\n} from 'leaflet';\r\nimport { Task, Util as EsriUtil } from 'esri-leaflet';\r\nimport { WorldGeocodingServiceUrl } from '../helper';\r\n\r\nexport var Suggest = Task.extend({\r\n  path: 'suggest',\r\n\r\n  params: {},\r\n\r\n  setters: {\r\n    text: 'text',\r\n    category: 'category',\r\n    countries: 'countryCode',\r\n    maxSuggestions: 'maxSuggestions'\r\n  },\r\n\r\n  initialize: function (options) {\r\n    options = options || {};\r\n    if (!options.url) {\r\n      options.url = WorldGeocodingServiceUrl;\r\n      options.supportsSuggest = true;\r\n    }\r\n    Task.prototype.initialize.call(this, options);\r\n  },\r\n\r\n  within: function (bounds) {\r\n    bounds = latLngBounds(bounds);\r\n    var center = bounds.getCenter();\r\n    var ne = bounds.getNorthWest();\r\n    this.params.location = center.lng + ',' + center.lat;\r\n    this.params.distance = Math.min(Math.max(center.distanceTo(ne), 2000), 50000);\r\n    this.params.searchExtent = EsriUtil.boundsToExtent(bounds);\r\n    return this;\r\n  },\r\n\r\n  nearby: function (coords, radius) {\r\n    var centroid = latLng(coords);\r\n    this.params.location = centroid.lng + ',' + centroid.lat;\r\n    if (radius) {\r\n      this.params.distance = Math.min(Math.max(radius, 2000), 50000);\r\n    }\r\n    return this;\r\n  },\r\n\r\n  run: function (callback, context) {\r\n    if (this.options.supportsSuggest) {\r\n      return this.request(function (error, response) {\r\n        callback.call(context, error, response, response);\r\n      }, this);\r\n    } else {\r\n      console.warn('this geocoding service does not support asking for suggestions');\r\n    }\r\n  }\r\n\r\n});\r\n\r\nexport function suggest (options) {\r\n  return new Suggest(options);\r\n}\r\n\r\nexport default suggest;\r\n","import { Service } from 'esri-leaflet';\r\nimport { WorldGeocodingServiceUrl } from '../helper';\r\nimport geocode from '../Tasks/Geocode';\r\nimport reverseGeocode from '../Tasks/ReverseGeocode';\r\nimport suggest from '../Tasks/Suggest';\r\n\r\nexport var GeocodeService = Service.extend({\r\n  initialize: function (options) {\r\n    options = options || {};\r\n    if (options.apikey) {\r\n      options.token = options.apikey;\r\n    }\r\n    if (options.url) {\r\n      Service.prototype.initialize.call(this, options);\r\n      this._confirmSuggestSupport();\r\n    } else {\r\n      options.url = WorldGeocodingServiceUrl;\r\n      options.supportsSuggest = true;\r\n      Service.prototype.initialize.call(this, options);\r\n    }\r\n  },\r\n\r\n  geocode: function () {\r\n    return geocode(this);\r\n  },\r\n\r\n  reverse: function () {\r\n    return reverseGeocode(this);\r\n  },\r\n\r\n  suggest: function () {\r\n    // requires either the Esri World Geocoding Service or a <10.3 ArcGIS Server Geocoding Service that supports suggest.\r\n    return suggest(this);\r\n  },\r\n\r\n  _confirmSuggestSupport: function () {\r\n    this.metadata(function (error, response) {\r\n      if (error) { return; }\r\n      // pre 10.3 geocoding services dont list capabilities (and dont support maxLocations)\r\n      // only SOME individual services have been configured to support asking for suggestions\r\n      if (!response.capabilities) {\r\n        this.options.supportsSuggest = false;\r\n      } else if (response.capabilities.indexOf('Suggest') > -1) {\r\n        this.options.supportsSuggest = true;\r\n      } else {\r\n        this.options.supportsSuggest = false;\r\n      }\r\n      // whether the service supports suggest or not, utilize the metadata response to determine the appropriate parameter name for single line geocoding requests\r\n      this.options.customParam = response.singleLineAddressField.name;\r\n    }, this);\r\n  }\r\n});\r\n\r\nexport function geocodeService (options) {\r\n  return new GeocodeService(options);\r\n}\r\n\r\nexport default geocodeService;\r\n","import { Evented, Util, latLngBounds } from 'leaflet';\r\n\r\nexport var GeosearchCore = Evented.extend({\r\n\r\n  options: {\r\n    zoomToResult: true,\r\n    useMapBounds: 12,\r\n    searchBounds: null\r\n  },\r\n\r\n  initialize: function (control, options) {\r\n    Util.setOptions(this, options);\r\n    this._control = control;\r\n\r\n    if (!options || !options.providers || !options.providers.length) {\r\n      throw new Error('You must specify at least one provider');\r\n    }\r\n\r\n    this._providers = options.providers;\r\n  },\r\n\r\n  _geocode: function (text, key, provider) {\r\n    var activeRequests = 0;\r\n    var allResults = [];\r\n    var bounds;\r\n\r\n    var callback = Util.bind(function (error, results) {\r\n      activeRequests--;\r\n      if (error) {\r\n        return;\r\n      }\r\n\r\n      if (results) {\r\n        allResults = allResults.concat(results);\r\n      }\r\n\r\n      if (activeRequests <= 0) {\r\n        bounds = this._boundsFromResults(allResults);\r\n\r\n        this.fire('results', {\r\n          results: allResults,\r\n          bounds: bounds,\r\n          latlng: (bounds) ? bounds.getCenter() : undefined,\r\n          text: text\r\n        }, true);\r\n\r\n        if (this.options.zoomToResult && bounds) {\r\n          this._control._map.fitBounds(bounds);\r\n        }\r\n\r\n        this.fire('load');\r\n      }\r\n    }, this);\r\n\r\n    if (key) {\r\n      activeRequests++;\r\n      provider.results(text, key, this._searchBounds(), callback);\r\n    } else {\r\n      for (var i = 0; i < this._providers.length; i++) {\r\n        activeRequests++;\r\n        this._providers[i].results(text, key, this._searchBounds(), callback);\r\n      }\r\n    }\r\n  },\r\n\r\n  _suggest: function (text) {\r\n    var activeRequests = this._providers.length;\r\n    var suggestionsLength = 0;\r\n\r\n    var createCallback = Util.bind(function (text, provider) {\r\n      return Util.bind(function (error, suggestions) {\r\n        activeRequests = activeRequests - 1;\r\n        suggestionsLength += suggestions.length;\r\n\r\n        if (error) {\r\n          // an error occurred for one of the providers' suggest requests\r\n          this._control._clearProviderSuggestions(provider);\r\n\r\n          // perform additional cleanup when all requests are finished\r\n          this._control._finalizeSuggestions(activeRequests, suggestionsLength);\r\n\r\n          return;\r\n        }\r\n\r\n        if (suggestions.length) {\r\n          for (var i = 0; i < suggestions.length; i++) {\r\n            suggestions[i].provider = provider;\r\n          }\r\n        } else {\r\n          // we still need to update the UI\r\n          this._control._renderSuggestions(suggestions);\r\n        }\r\n\r\n        if (provider._lastRender !== text) {\r\n          this._control._clearProviderSuggestions(provider);\r\n        }\r\n\r\n        if (suggestions.length && this._control._input.value === text) {\r\n          provider._lastRender = text;\r\n          this._control._renderSuggestions(suggestions);\r\n        }\r\n\r\n        // perform additional cleanup when all requests are finished\r\n        this._control._finalizeSuggestions(activeRequests, suggestionsLength);\r\n      }, this);\r\n    }, this);\r\n\r\n    this._pendingSuggestions = [];\r\n\r\n    for (var i = 0; i < this._providers.length; i++) {\r\n      var provider = this._providers[i];\r\n      var request = provider.suggestions(text, this._searchBounds(), createCallback(text, provider));\r\n      this._pendingSuggestions.push(request);\r\n    }\r\n  },\r\n\r\n  _searchBounds: function () {\r\n    if (this.options.searchBounds !== null) {\r\n      return this.options.searchBounds;\r\n    }\r\n\r\n    if (this.options.useMapBounds === false) {\r\n      return null;\r\n    }\r\n\r\n    if (this.options.useMapBounds === true) {\r\n      return this._control._map.getBounds();\r\n    }\r\n\r\n    if (this.options.useMapBounds <= this._control._map.getZoom()) {\r\n      return this._control._map.getBounds();\r\n    }\r\n\r\n    return null;\r\n  },\r\n\r\n  _boundsFromResults: function (results) {\r\n    if (!results.length) {\r\n      return;\r\n    }\r\n\r\n    var nullIsland = latLngBounds([0, 0], [0, 0]);\r\n    var resultBounds = [];\r\n    var resultLatlngs = [];\r\n\r\n    // collect the bounds and center of each result\r\n    for (var i = results.length - 1; i >= 0; i--) {\r\n      var result = results[i];\r\n\r\n      resultLatlngs.push(result.latlng);\r\n\r\n      // make sure bounds are valid and not 0,0. sometimes bounds are incorrect or not present\r\n      if (result.bounds && result.bounds.isValid() && !result.bounds.equals(nullIsland)) {\r\n        resultBounds.push(result.bounds);\r\n      }\r\n    }\r\n\r\n    // form a bounds object containing all center points\r\n    var bounds = latLngBounds(resultLatlngs);\r\n\r\n    // and extend it to contain all bounds objects\r\n    for (var j = 0; j < resultBounds.length; j++) {\r\n      bounds.extend(resultBounds[j]);\r\n    }\r\n\r\n    return bounds;\r\n  },\r\n\r\n  _getAttribution: function () {\r\n    var attribs = [];\r\n    var providers = this._providers;\r\n\r\n    for (var i = 0; i < providers.length; i++) {\r\n      if (providers[i].options.attribution) {\r\n        attribs.push(providers[i].options.attribution);\r\n      }\r\n    }\r\n\r\n    return attribs.join(', ');\r\n  }\r\n\r\n});\r\n\r\nexport function geosearchCore (control, options) {\r\n  return new GeosearchCore(control, options);\r\n}\r\n\r\nexport default geosearchCore;\r\n","import { GeocodeService } from '../Services/Geocode';\r\n\r\nexport var ArcgisOnlineProvider = GeocodeService.extend({\r\n  options: {\r\n    label: 'Places and Addresses',\r\n    maxResults: 5\r\n  },\r\n\r\n  suggestions: function (text, bounds, callback) {\r\n    var request = this.suggest().text(text);\r\n\r\n    if (bounds) {\r\n      request.within(bounds);\r\n    }\r\n\r\n    if (this.options.nearby) {\r\n      // \"distance\"/\"radius\" is not supported by the ArcGIS Online Geocoder,\r\n      // so that is intentionally not passed here:\r\n      request.nearby(this.options.nearby);\r\n    }\r\n\r\n    if (this.options.countries) {\r\n      request.countries(this.options.countries);\r\n    }\r\n\r\n    if (this.options.categories) {\r\n      request.category(this.options.categories);\r\n    }\r\n\r\n    // 15 is the maximum number of suggestions that can be returned\r\n    request.maxSuggestions(this.options.maxResults);\r\n\r\n    return request.run(function (error, results, response) {\r\n      var suggestions = [];\r\n      if (!error) {\r\n        while (response.suggestions.length && suggestions.length <= (this.options.maxResults - 1)) {\r\n          var suggestion = response.suggestions.shift();\r\n          if (!suggestion.isCollection) {\r\n            suggestions.push({\r\n              text: suggestion.text,\r\n              unformattedText: suggestion.text,\r\n              magicKey: suggestion.magicKey\r\n            });\r\n          }\r\n        }\r\n      }\r\n      callback(error, suggestions);\r\n    }, this);\r\n  },\r\n\r\n  results: function (text, key, bounds, callback) {\r\n    var request = this.geocode().text(text);\r\n\r\n    if (key) {\r\n      request.key(key);\r\n    }\r\n    // in the future Address/StreetName geocoding requests that include a magicKey will always only return one match\r\n    request.maxLocations(this.options.maxResults);\r\n\r\n    if (bounds) {\r\n      request.within(bounds);\r\n    }\r\n\r\n    if (this.options.forStorage) {\r\n      request.forStorage(true);\r\n    }\r\n\r\n    if (this.options.nearby) {\r\n      // \"distance\"/\"radius\" is not supported by the ArcGIS Online Geocoder,\r\n      // so that is intentionally not passed here:\r\n      request.nearby(this.options.nearby);\r\n    }\r\n\r\n    if (this.options.countries) {\r\n      request.countries(this.options.countries);\r\n    }\r\n\r\n    if (this.options.categories) {\r\n      request.category(this.options.categories);\r\n    }\r\n\r\n    return request.run(function (error, response) {\r\n      callback(error, response.results);\r\n    }, this);\r\n  }\r\n});\r\n\r\nexport function arcgisOnlineProvider (options) {\r\n  return new ArcgisOnlineProvider(options);\r\n}\r\n\r\nexport default arcgisOnlineProvider;\r\n","import {\r\n  Control,\r\n  DomEvent,\r\n  DomUtil,\r\n  Evented,\r\n  Util,\r\n  latLngBounds\r\n} from 'leaflet';\r\nimport { geosearchCore } from '../Classes/GeosearchCore';\r\nimport { arcgisOnlineProvider } from '../Providers/ArcgisOnlineGeocoder';\r\nimport { Util as EsriUtil } from 'esri-leaflet';\r\n\r\nexport var Geosearch = Control.extend({\r\n  includes: Evented.prototype,\r\n\r\n  options: {\r\n    position: 'topleft',\r\n    collapseAfterResult: true,\r\n    expanded: false,\r\n    allowMultipleResults: true,\r\n    placeholder: 'Search for places or addresses',\r\n    title: 'Location Search'\r\n  },\r\n\r\n  initialize: function (options) {\r\n    Util.setOptions(this, options);\r\n\r\n    if (!options || !options.providers || !options.providers.length) {\r\n      if (!options) {\r\n        options = {};\r\n      }\r\n      options.providers = [arcgisOnlineProvider()];\r\n    }\r\n\r\n    // instantiate the underlying class and pass along options\r\n    this._geosearchCore = geosearchCore(this, options);\r\n    this._geosearchCore._providers = options.providers;\r\n\r\n    // bubble each providers events to the control\r\n    this._geosearchCore.addEventParent(this);\r\n    for (var i = 0; i < this._geosearchCore._providers.length; i++) {\r\n      this._geosearchCore._providers[i].addEventParent(this);\r\n    }\r\n\r\n    this._geosearchCore._pendingSuggestions = [];\r\n\r\n    Control.prototype.initialize.call(this, options);\r\n  },\r\n\r\n  _renderSuggestions: function (suggestions) {\r\n    var currentGroup;\r\n\r\n    if (suggestions.length > 0) {\r\n      this._suggestions.style.display = 'block';\r\n    }\r\n\r\n    var list;\r\n    var header;\r\n    var suggestionTextArray = [];\r\n\r\n    for (var i = 0; i < suggestions.length; i++) {\r\n      var suggestion = suggestions[i];\r\n      if (!header && this._geosearchCore._providers.length > 1 && currentGroup !== suggestion.provider.options.label) {\r\n        header = DomUtil.create('div', 'geocoder-control-header', suggestion.provider._contentsElement);\r\n        header.textContent = suggestion.provider.options.label;\r\n        header.innerText = suggestion.provider.options.label;\r\n        currentGroup = suggestion.provider.options.label;\r\n      }\r\n\r\n      if (!list) {\r\n        list = DomUtil.create('ul', 'geocoder-control-list', suggestion.provider._contentsElement);\r\n      }\r\n\r\n      if (suggestionTextArray.indexOf(suggestion.text) === -1) {\r\n        var suggestionItem = DomUtil.create('li', 'geocoder-control-suggestion', list);\r\n\r\n        suggestionItem.innerHTML = suggestion.text;\r\n        suggestionItem.provider = suggestion.provider;\r\n        suggestionItem['data-magic-key'] = suggestion.magicKey;\r\n        suggestionItem.unformattedText = suggestion.unformattedText;\r\n      } else {\r\n        for (var j = 0; j < list.childNodes.length; j++) {\r\n          // if the same text already appears in the list of suggestions, append an additional ObjectID to its magicKey instead\r\n          if (list.childNodes[j].innerHTML === suggestion.text) {\r\n            list.childNodes[j]['data-magic-key'] += ',' + suggestion.magicKey;\r\n          }\r\n        }\r\n      }\r\n      suggestionTextArray.push(suggestion.text);\r\n    }\r\n\r\n    // when the geocoder position is either \"topleft\" or \"topright\":\r\n    // set the maxHeight of the suggestions box to:\r\n    //  map height\r\n    //  - suggestions offset (distance from top of suggestions to top of control)\r\n    //  - control offset (distance from top of control to top of map)\r\n    //  - 10 (extra padding)\r\n    if (this.getPosition().indexOf('top') > -1) {\r\n      this._suggestions.style.maxHeight = (this._map.getSize().y - this._suggestions.offsetTop - this._wrapper.offsetTop - 10) + 'px';\r\n    }\r\n\r\n    // when the geocoder position is either \"bottomleft\" or \"bottomright\":\r\n    // 1. set the maxHeight of the suggestions box to:\r\n    //  map height\r\n    //  - corner control container offsetHeight (height of container of bottom corner)\r\n    //  - control offsetHeight (height of geocoder control wrapper, the main expandable button)\r\n    // 2. to move it up, set the top of the suggestions box to:\r\n    //  negative offsetHeight of suggestions box (its own negative height now that it has children elements\r\n    //  - control offsetHeight (height of geocoder control wrapper, the main expandable button)\r\n    //  + 20 (extra spacing)\r\n    if (this.getPosition().indexOf('bottom') > -1) {\r\n      this._setSuggestionsBottomPosition();\r\n    }\r\n  },\r\n\r\n  _setSuggestionsBottomPosition: function () {\r\n    this._suggestions.style.maxHeight = (this._map.getSize().y - this._map._controlCorners[this.getPosition()].offsetHeight - this._wrapper.offsetHeight) + 'px';\r\n    this._suggestions.style.top = (-this._suggestions.offsetHeight - this._wrapper.offsetHeight + 20) + 'px';\r\n  },\r\n\r\n  _boundsFromResults: function (results) {\r\n    if (!results.length) {\r\n      return;\r\n    }\r\n\r\n    var nullIsland = latLngBounds([0, 0], [0, 0]);\r\n    var resultBounds = [];\r\n    var resultLatlngs = [];\r\n\r\n    // collect the bounds and center of each result\r\n    for (var i = results.length - 1; i >= 0; i--) {\r\n      var result = results[i];\r\n\r\n      resultLatlngs.push(result.latlng);\r\n\r\n      // make sure bounds are valid and not 0,0. sometimes bounds are incorrect or not present\r\n      if (result.bounds && result.bounds.isValid() && !result.bounds.equals(nullIsland)) {\r\n        resultBounds.push(result.bounds);\r\n      }\r\n    }\r\n\r\n    // form a bounds object containing all center points\r\n    var bounds = latLngBounds(resultLatlngs);\r\n\r\n    // and extend it to contain all bounds objects\r\n    for (var j = 0; j < resultBounds.length; j++) {\r\n      bounds.extend(resultBounds[j]);\r\n    }\r\n\r\n    return bounds;\r\n  },\r\n\r\n  clear: function () {\r\n    this._clearAllSuggestions();\r\n\r\n    if (this.options.collapseAfterResult) {\r\n      this._input.value = '';\r\n      this._lastValue = '';\r\n      this._input.placeholder = '';\r\n      DomUtil.removeClass(this._wrapper, 'geocoder-control-expanded');\r\n    }\r\n\r\n    if (!this._map.scrollWheelZoom.enabled() && this._map.options.scrollWheelZoom) {\r\n      this._map.scrollWheelZoom.enable();\r\n    }\r\n  },\r\n\r\n  _clearAllSuggestions: function () {\r\n    this._suggestions.style.display = 'none';\r\n\r\n    for (var i = 0; i < this.options.providers.length; i++) {\r\n      this._clearProviderSuggestions(this.options.providers[i]);\r\n    }\r\n  },\r\n\r\n  _clearProviderSuggestions: function (provider) {\r\n    provider._contentsElement.innerHTML = '';\r\n  },\r\n\r\n  _finalizeSuggestions: function (activeRequests, suggestionsLength) {\r\n    // check if all requests are finished to remove the loading indicator\r\n    if (!activeRequests) {\r\n      DomUtil.removeClass(this._input, 'geocoder-control-loading');\r\n\r\n      // when the geocoder position is either \"bottomleft\" or \"bottomright\",\r\n      // it is necessary in some cases to recalculate the maxHeight and top values of the this._suggestions element,\r\n      // even though this is also being done after each provider returns their own suggestions\r\n      if (this.getPosition().indexOf('bottom') > -1) {\r\n        this._setSuggestionsBottomPosition();\r\n      }\r\n\r\n      // also check if there were 0 total suggest results to clear the parent suggestions element\r\n      // otherwise its display value may be \"block\" instead of \"none\"\r\n      if (!suggestionsLength) {\r\n        this._clearAllSuggestions();\r\n      }\r\n    }\r\n  },\r\n\r\n  _setupClick: function () {\r\n    DomUtil.addClass(this._wrapper, 'geocoder-control-expanded');\r\n    this._input.focus();\r\n  },\r\n\r\n  disable: function () {\r\n    this._input.disabled = true;\r\n    DomUtil.addClass(this._input, 'geocoder-control-input-disabled');\r\n    DomEvent.removeListener(this._wrapper, 'click', this._setupClick, this);\r\n  },\r\n\r\n  enable: function () {\r\n    this._input.disabled = false;\r\n    DomUtil.removeClass(this._input, 'geocoder-control-input-disabled');\r\n    DomEvent.addListener(this._wrapper, 'click', this._setupClick, this);\r\n  },\r\n\r\n  getAttribution: function () {\r\n    var attribs = [];\r\n\r\n    for (var i = 0; i < this._providers.length; i++) {\r\n      if (this._providers[i].options.attribution) {\r\n        attribs.push(this._providers[i].options.attribution);\r\n      }\r\n    }\r\n\r\n    return attribs.join(', ');\r\n  },\r\n\r\n  geocodeSuggestion: function (e) {\r\n    var suggestionItem = e.target || e.srcElement;\r\n\r\n    if (\r\n      suggestionItem.classList.contains('geocoder-control-suggestions') ||\r\n      suggestionItem.classList.contains('geocoder-control-header')\r\n    ) {\r\n      return;\r\n    }\r\n\r\n    // make sure and point at the actual 'geocoder-control-suggestion'\r\n    if (suggestionItem.classList.length < 1) {\r\n      suggestionItem = suggestionItem.parentNode;\r\n    }\r\n\r\n    this._geosearchCore._geocode(suggestionItem.unformattedText, suggestionItem['data-magic-key'], suggestionItem.provider);\r\n    this.clear();\r\n  },\r\n\r\n  onAdd: function (map) {\r\n    // include 'Powered by Esri' in map attribution\r\n    EsriUtil.setEsriAttribution(map);\r\n\r\n    this._map = map;\r\n    this._wrapper = DomUtil.create('div', 'geocoder-control');\r\n    this._input = DomUtil.create('input', 'geocoder-control-input leaflet-bar', this._wrapper);\r\n    this._input.title = this.options.title;\r\n\r\n    if (this.options.expanded) {\r\n      DomUtil.addClass(this._wrapper, 'geocoder-control-expanded');\r\n      this._input.placeholder = this.options.placeholder;\r\n    }\r\n\r\n    // create the main suggested results container element\r\n    this._suggestions = DomUtil.create('div', 'geocoder-control-suggestions leaflet-bar', this._wrapper);\r\n\r\n    // create a child contents container element for each provider inside of this._suggestions\r\n    // to maintain the configured order of providers for suggested results\r\n    for (var i = 0; i < this.options.providers.length; i++) {\r\n      this.options.providers[i]._contentsElement = DomUtil.create('div', null, this._suggestions);\r\n    }\r\n\r\n    var credits = this._geosearchCore._getAttribution();\r\n\r\n    if (map.attributionControl) {\r\n      map.attributionControl.addAttribution(credits);\r\n    }\r\n\r\n    DomEvent.addListener(this._input, 'focus', function (e) {\r\n      this._input.placeholder = this.options.placeholder;\r\n      DomUtil.addClass(this._wrapper, 'geocoder-control-expanded');\r\n    }, this);\r\n\r\n    DomEvent.addListener(this._wrapper, 'click', this._setupClick, this);\r\n\r\n    // make sure both click and touch spawn an address/poi search\r\n    DomEvent.addListener(this._suggestions, 'mousedown', this.geocodeSuggestion, this);\r\n\r\n    DomEvent.addListener(this._input, 'blur', function (e) {\r\n      // TODO: this is too greedy and should not \"clear\"\r\n      // when trying to use the scrollbar or clicking on a non-suggestion item (such as a provider header)\r\n      this.clear();\r\n    }, this);\r\n\r\n    DomEvent.addListener(this._input, 'keydown', function (e) {\r\n      var text = (e.target || e.srcElement).value;\r\n\r\n      DomUtil.addClass(this._wrapper, 'geocoder-control-expanded');\r\n\r\n      var list = this._suggestions.querySelectorAll('.' + 'geocoder-control-suggestion');\r\n      var selected = this._suggestions.querySelectorAll('.' + 'geocoder-control-selected')[0];\r\n      var selectedPosition;\r\n\r\n      for (var i = 0; i < list.length; i++) {\r\n        if (list[i] === selected) {\r\n          selectedPosition = i;\r\n          break;\r\n        }\r\n      }\r\n\r\n      switch (e.keyCode) {\r\n        case 13:\r\n          /*\r\n            if an item has been selected, geocode it\r\n            if focus is on the input textbox, geocode only if multiple results are allowed and more than two characters are present, or if a single suggestion is displayed.\r\n            if less than two characters have been typed, abort the geocode\r\n          */\r\n          if (selected) {\r\n            this._input.value = selected.innerText;\r\n            this._geosearchCore._geocode(selected.unformattedText, selected['data-magic-key'], selected.provider);\r\n            this.clear();\r\n          } else if (this.options.allowMultipleResults && text.length >= 2) {\r\n            this._geosearchCore._geocode(this._input.value, undefined);\r\n            this.clear();\r\n          } else {\r\n            if (list.length === 1) {\r\n              DomUtil.addClass(list[0], 'geocoder-control-selected');\r\n              this._geosearchCore._geocode(list[0].innerHTML, list[0]['data-magic-key'], list[0].provider);\r\n            } else {\r\n              this.clear();\r\n              this._input.blur();\r\n            }\r\n          }\r\n          DomEvent.preventDefault(e);\r\n          break;\r\n        case 38:\r\n          if (selected) {\r\n            DomUtil.removeClass(selected, 'geocoder-control-selected');\r\n          }\r\n\r\n          var previousItem = list[selectedPosition - 1];\r\n\r\n          if (selected && previousItem) {\r\n            DomUtil.addClass(previousItem, 'geocoder-control-selected');\r\n          } else {\r\n            DomUtil.addClass(list[list.length - 1], 'geocoder-control-selected');\r\n          }\r\n          DomEvent.preventDefault(e);\r\n          break;\r\n        case 40:\r\n          if (selected) {\r\n            DomUtil.removeClass(selected, 'geocoder-control-selected');\r\n          }\r\n\r\n          var nextItem = list[selectedPosition + 1];\r\n\r\n          if (selected && nextItem) {\r\n            DomUtil.addClass(nextItem, 'geocoder-control-selected');\r\n          } else {\r\n            DomUtil.addClass(list[0], 'geocoder-control-selected');\r\n          }\r\n          DomEvent.preventDefault(e);\r\n          break;\r\n        default:\r\n          // when the input changes we should cancel all pending suggestion requests if possible to avoid result collisions\r\n          for (var x = 0; x < this._geosearchCore._pendingSuggestions.length; x++) {\r\n            var request = this._geosearchCore._pendingSuggestions[x];\r\n            if (request && request.abort && !request.id) {\r\n              request.abort();\r\n            }\r\n          }\r\n          break;\r\n      }\r\n    }, this);\r\n\r\n    DomEvent.addListener(this._input, 'keyup', Util.throttle(function (e) {\r\n      var key = e.which || e.keyCode;\r\n      var text = (e.target || e.srcElement).value;\r\n\r\n      // require at least 2 characters for suggestions\r\n      if (text.length < 2) {\r\n        this._lastValue = this._input.value;\r\n        this._clearAllSuggestions();\r\n        DomUtil.removeClass(this._input, 'geocoder-control-loading');\r\n        return;\r\n      }\r\n\r\n      // if this is the escape key it will clear the input so clear suggestions\r\n      if (key === 27) {\r\n        this._clearAllSuggestions();\r\n        return;\r\n      }\r\n\r\n      // if this is NOT the up/down arrows or enter make a suggestion\r\n      if (key !== 13 && key !== 38 && key !== 40) {\r\n        if (this._input.value !== this._lastValue) {\r\n          this._lastValue = this._input.value;\r\n          DomUtil.addClass(this._input, 'geocoder-control-loading');\r\n          this._geosearchCore._suggest(text);\r\n        }\r\n      }\r\n    }, 50, this), this);\r\n\r\n    DomEvent.disableClickPropagation(this._wrapper);\r\n\r\n    // when mouse moves over suggestions disable scroll wheel zoom if its enabled\r\n    DomEvent.addListener(this._suggestions, 'mouseover', function (e) {\r\n      if (map.scrollWheelZoom.enabled() && map.options.scrollWheelZoom) {\r\n        map.scrollWheelZoom.disable();\r\n      }\r\n    });\r\n\r\n    // when mouse moves leaves suggestions enable scroll wheel zoom if its disabled\r\n    DomEvent.addListener(this._suggestions, 'mouseout', function (e) {\r\n      if (!map.scrollWheelZoom.enabled() && map.options.scrollWheelZoom) {\r\n        map.scrollWheelZoom.enable();\r\n      }\r\n    });\r\n\r\n    this._geosearchCore.on('load', function (e) {\r\n      DomUtil.removeClass(this._input, 'geocoder-control-loading');\r\n      this.clear();\r\n      this._input.blur();\r\n    }, this);\r\n\r\n    return this._wrapper;\r\n  }\r\n});\r\n\r\nexport function geosearch (options) {\r\n  return new Geosearch(options);\r\n}\r\n\r\nexport default geosearch;\r\n","import { Util, geoJson, latLngBounds } from 'leaflet';\r\nimport { FeatureLayerService } from 'esri-leaflet';\r\n\r\nexport var FeatureLayerProvider = FeatureLayerService.extend({\r\n  options: {\r\n    label: 'Feature Layer',\r\n    maxResults: 5,\r\n    bufferRadius: 1000,\r\n    searchMode: 'contain',\r\n    formatSuggestion: function (feature) {\r\n      return feature.properties[this.options.searchFields[0]];\r\n    }\r\n  },\r\n\r\n  initialize: function (options) {\r\n    if (options.apikey) {\r\n      options.token = options.apikey;\r\n    }\r\n    FeatureLayerService.prototype.initialize.call(this, options);\r\n    if (typeof this.options.searchFields === 'string') {\r\n      this.options.searchFields = [this.options.searchFields];\r\n    }\r\n    this._suggestionsQuery = this.query();\r\n    this._resultsQuery = this.query();\r\n  },\r\n\r\n  suggestions: function (text, bounds, callback) {\r\n    var query = this._suggestionsQuery.where(this._buildQuery(text))\r\n      .returnGeometry(false);\r\n\r\n    if (bounds) {\r\n      query.intersects(bounds);\r\n    }\r\n\r\n    if (this.options.idField) {\r\n      query.fields([this.options.idField].concat(this.options.searchFields));\r\n    }\r\n\r\n    var request = query.run(function (error, results, raw) {\r\n      if (error) {\r\n        callback(error, []);\r\n      } else {\r\n        this.options.idField = raw.objectIdFieldName;\r\n        var suggestions = [];\r\n        for (var i = results.features.length - 1; i >= 0; i--) {\r\n          var feature = results.features[i];\r\n          suggestions.push({\r\n            text: this.options.formatSuggestion.call(this, feature),\r\n            unformattedText: feature.properties[this.options.searchFields[0]],\r\n            magicKey: feature.id\r\n          });\r\n        }\r\n        callback(error, suggestions.slice(0, this.options.maxResults));\r\n      }\r\n    }, this);\r\n\r\n    return request;\r\n  },\r\n\r\n  results: function (text, key, bounds, callback) {\r\n    var query = this._resultsQuery;\r\n\r\n    if (key) {\r\n      // if there are 1 or more keys available, use query.featureIds()\r\n      delete query.params.where;\r\n      query.featureIds([key]);\r\n    } else {\r\n      // if there are no keys available, use query.where()\r\n      query.where(this._buildQuery(text));\r\n    }\r\n\r\n    if (bounds) {\r\n      query.within(bounds);\r\n    }\r\n\r\n    return query.run(Util.bind(function (error, features) {\r\n      var results = [];\r\n      for (var i = 0; i < features.features.length; i++) {\r\n        var feature = features.features[i];\r\n        if (feature) {\r\n          var bounds = this._featureBounds(feature);\r\n\r\n          var result = {\r\n            latlng: bounds.getCenter(),\r\n            bounds: bounds,\r\n            text: this.options.formatSuggestion.call(this, feature),\r\n            properties: feature.properties,\r\n            geojson: feature\r\n          };\r\n\r\n          results.push(result);\r\n\r\n          // clear query parameters for the next search\r\n          delete this._resultsQuery.params['objectIds'];\r\n        }\r\n      }\r\n      callback(error, results);\r\n    }, this));\r\n  },\r\n\r\n  orderBy: function (fieldName, order) {\r\n    this._suggestionsQuery.orderBy(fieldName, order);\r\n  },\r\n\r\n  _buildQuery: function (text) {\r\n    var queryString = [];\r\n\r\n    for (var i = this.options.searchFields.length - 1; i >= 0; i--) {\r\n      var field = 'upper(\"' + this.options.searchFields[i] + '\")';\r\n      if (this.options.searchMode === 'contain') {\r\n        queryString.push(field + \" LIKE upper('%\" + text + \"%')\");\r\n      } else if (this.options.searchMode === 'startWith') {\r\n        queryString.push(field + \" LIKE upper('\" + text + \"%')\");\r\n      } else if (this.options.searchMode === 'endWith') {\r\n        queryString.push(field + \" LIKE upper('%\" + text + \"')\");\r\n      } else if (this.options.searchMode === 'strict') {\r\n        queryString.push(field + \" LIKE upper('\" + text + \"')\");\r\n      } else {\r\n        throw new Error('L.esri.Geocoding.featureLayerProvider: Invalid parameter for \"searchMode\". Use one of \"contain\", \"startWith\", \"endWith\", or \"strict\"');\r\n      }\r\n    }\r\n    if (this.options.where) {\r\n      return this.options.where + ' AND (' + queryString.join(' OR ') + ')';\r\n    } else {\r\n      return queryString.join(' OR ');\r\n    }\r\n  },\r\n\r\n  _featureBounds: function (feature) {\r\n    var geojson = geoJson(feature);\r\n    if (feature.geometry.type === 'Point') {\r\n      var center = geojson.getBounds().getCenter();\r\n      var lngRadius = ((this.options.bufferRadius / 40075017) * 360) / Math.cos((180 / Math.PI) * center.lat);\r\n      var latRadius = (this.options.bufferRadius / 40075017) * 360;\r\n      return latLngBounds([center.lat - latRadius, center.lng - lngRadius], [center.lat + latRadius, center.lng + lngRadius]);\r\n    } else {\r\n      return geojson.getBounds();\r\n    }\r\n  }\r\n});\r\n\r\nexport function featureLayerProvider (options) {\r\n  return new FeatureLayerProvider(options);\r\n}\r\n\r\nexport default featureLayerProvider;\r\n","import { Util, geoJson, latLngBounds } from 'leaflet';\r\nimport { MapService } from 'esri-leaflet';\r\n\r\nexport var MapServiceProvider = MapService.extend({\r\n  options: {\r\n    layers: [0],\r\n    label: 'Map Service',\r\n    bufferRadius: 1000,\r\n    maxResults: 5,\r\n    formatSuggestion: function (feature) {\r\n      return feature.properties[feature.displayFieldName] + ' <small>' + feature.layerName + '</small>';\r\n    }\r\n  },\r\n\r\n  initialize: function (options) {\r\n    if (options.apikey) {\r\n      options.token = options.apikey;\r\n    }\r\n    MapService.prototype.initialize.call(this, options);\r\n    this._getIdFields();\r\n  },\r\n\r\n  suggestions: function (text, bounds, callback) {\r\n    var request = this.find().text(text).fields(this.options.searchFields).returnGeometry(false).layers(this.options.layers);\r\n\r\n    return request.run(function (error, results, raw) {\r\n      var suggestions = [];\r\n      if (!error) {\r\n        var count = Math.min(this.options.maxResults, results.features.length);\r\n        raw.results = raw.results.reverse();\r\n        for (var i = 0; i < count; i++) {\r\n          var feature = results.features[i];\r\n          var result = raw.results[i];\r\n          var layer = result.layerId;\r\n          var idField = this._idFields[layer];\r\n          feature.layerId = layer;\r\n          feature.layerName = this._layerNames[layer];\r\n          feature.displayFieldName = this._displayFields[layer];\r\n          if (idField) {\r\n            suggestions.push({\r\n              text: this.options.formatSuggestion.call(this, feature),\r\n              unformattedText: feature.properties[feature.displayFieldName],\r\n              magicKey: result.attributes[idField] + ':' + layer\r\n            });\r\n          }\r\n        }\r\n      }\r\n      callback(error, suggestions.reverse());\r\n    }, this);\r\n  },\r\n\r\n  results: function (text, key, bounds, callback) {\r\n    var results = [];\r\n    var request;\r\n\r\n    if (key && !key.includes(',')) {\r\n      // if there is only 1 key available, use query()\r\n      var featureId = key.split(':')[0];\r\n      var layer = key.split(':')[1];\r\n      request = this.query().layer(layer).featureIds(featureId);\r\n    } else {\r\n      // if there are no keys or more than 1 keys available, use find()\r\n      request = this.find().text(text).fields(this.options.searchFields).layers(this.options.layers);\r\n    }\r\n\r\n    return request.run(function (error, features, response) {\r\n      if (!error) {\r\n        if (response.results) {\r\n          response.results = response.results.reverse();\r\n        }\r\n        for (var i = 0; i < features.features.length; i++) {\r\n          var feature = features.features[i];\r\n          layer = layer || response.results[i].layerId;\r\n\r\n          if (feature && layer !== undefined) {\r\n            var bounds = this._featureBounds(feature);\r\n            feature.layerId = layer;\r\n            feature.layerName = this._layerNames[layer];\r\n            feature.displayFieldName = this._displayFields[layer];\r\n\r\n            var result = {\r\n              latlng: bounds.getCenter(),\r\n              bounds: bounds,\r\n              text: this.options.formatSuggestion.call(this, feature),\r\n              properties: feature.properties,\r\n              geojson: feature\r\n            };\r\n\r\n            results.push(result);\r\n          }\r\n        }\r\n      }\r\n      callback(error, results.reverse());\r\n    }, this);\r\n  },\r\n\r\n  _featureBounds: function (feature) {\r\n    var geojson = geoJson(feature);\r\n    if (feature.geometry.type === 'Point') {\r\n      var center = geojson.getBounds().getCenter();\r\n      var lngRadius = ((this.options.bufferRadius / 40075017) * 360) / Math.cos((180 / Math.PI) * center.lat);\r\n      var latRadius = (this.options.bufferRadius / 40075017) * 360;\r\n      return latLngBounds([center.lat - latRadius, center.lng - lngRadius], [center.lat + latRadius, center.lng + lngRadius]);\r\n    } else {\r\n      return geojson.getBounds();\r\n    }\r\n  },\r\n\r\n  _layerMetadataCallback: function (layerid) {\r\n    return Util.bind(function (error, metadata) {\r\n      if (error) { return; }\r\n      this._displayFields[layerid] = metadata.displayField;\r\n      this._layerNames[layerid] = metadata.name;\r\n      for (var i = 0; i < metadata.fields.length; i++) {\r\n        var field = metadata.fields[i];\r\n        if (field.type === 'esriFieldTypeOID') {\r\n          this._idFields[layerid] = field.name;\r\n          break;\r\n        }\r\n      }\r\n    }, this);\r\n  },\r\n\r\n  _getIdFields: function () {\r\n    this._idFields = {};\r\n    this._displayFields = {};\r\n    this._layerNames = {};\r\n    for (var i = 0; i < this.options.layers.length; i++) {\r\n      var layer = this.options.layers[i];\r\n      this.get(layer, {}, this._layerMetadataCallback(layer));\r\n    }\r\n  }\r\n});\r\n\r\nexport function mapServiceProvider (options) {\r\n  return new MapServiceProvider(options);\r\n}\r\n\r\nexport default mapServiceProvider;\r\n","import { GeocodeService } from '../Services/Geocode';\r\n\r\nexport var GeocodeServiceProvider = GeocodeService.extend({\r\n  options: {\r\n    label: 'Geocode Server',\r\n    maxResults: 5\r\n  },\r\n\r\n  suggestions: function (text, bounds, callback) {\r\n    if (this.options.supportsSuggest) {\r\n      var request = this.suggest().text(text);\r\n      if (bounds) {\r\n        request.within(bounds);\r\n      }\r\n\r\n      return request.run(function (error, results, response) {\r\n        var suggestions = [];\r\n        if (!error) {\r\n          while (response.suggestions.length && suggestions.length <= (this.options.maxResults - 1)) {\r\n            var suggestion = response.suggestions.shift();\r\n            if (!suggestion.isCollection) {\r\n              suggestions.push({\r\n                text: suggestion.text,\r\n                unformattedText: suggestion.text,\r\n                magicKey: suggestion.magicKey\r\n              });\r\n            }\r\n          }\r\n        }\r\n        callback(error, suggestions);\r\n      }, this);\r\n    } else {\r\n      callback(null, []);\r\n      return false;\r\n    }\r\n  },\r\n\r\n  results: function (text, key, bounds, callback) {\r\n    var request = this.geocode().text(text);\r\n\r\n    if (key) {\r\n      request.key(key);\r\n    }\r\n\r\n    request.maxLocations(this.options.maxResults);\r\n\r\n    if (bounds) {\r\n      request.within(bounds);\r\n    }\r\n\r\n    return request.run(function (error, response) {\r\n      callback(error, response.results);\r\n    }, this);\r\n  }\r\n});\r\n\r\nexport function geocodeServiceProvider (options) {\r\n  return new GeocodeServiceProvider(options);\r\n}\r\n\r\nexport default geocodeServiceProvider;\r\n"]},"metadata":{},"sourceType":"script"}