{"ast":null,"code":"import { LatLngBounds, toLatLngBounds as latLngBounds, Layer, Browser, Util, Point, Bounds } from 'leaflet';\nexport var FeatureGrid = Layer.extend({\n  // @section\n  // @aka GridLayer options\n  options: {\n    // @option cellSize: Number|Point = 256\n    // Width and height of cells in the grid. Use a number if width and height are equal, or `L.point(width, height)` otherwise.\n    cellSize: 512,\n    // @option updateWhenIdle: Boolean = (depends)\n    // Load new cells only when panning ends.\n    // `true` by default on mobile browsers, in order to avoid too many requests and keep smooth navigation.\n    // `false` otherwise in order to display new cells _during_ panning, since it is easy to pan outside the\n    // [`keepBuffer`](#gridlayer-keepbuffer) option in desktop browsers.\n    updateWhenIdle: Browser.mobile,\n    // @option updateInterval: Number = 150\n    // Cells will not update more than once every `updateInterval` milliseconds when panning.\n    updateInterval: 150,\n    // @option noWrap: Boolean = false\n    // Whether the layer is wrapped around the antimeridian. If `true`, the\n    // GridLayer will only be displayed once at low zoom levels. Has no\n    // effect when the [map CRS](#map-crs) doesn't wrap around. Can be used\n    // in combination with [`bounds`](#gridlayer-bounds) to prevent requesting\n    // cells outside the CRS limits.\n    noWrap: false,\n    // @option keepBuffer: Number = 1.5\n    // When panning the map, keep this many rows and columns of cells before unloading them.\n    keepBuffer: 1.5\n  },\n  initialize: function (options) {\n    Util.setOptions(this, options);\n  },\n  onAdd: function (map) {\n    this._cells = {};\n    this._activeCells = {};\n\n    this._resetView();\n\n    this._update();\n  },\n  onRemove: function (map) {\n    this._removeAllCells();\n\n    this._cellZoom = undefined;\n  },\n  // @method isLoading: Boolean\n  // Returns `true` if any cell in the grid layer has not finished loading.\n  isLoading: function () {\n    return this._loading;\n  },\n  // @method redraw: this\n  // Causes the layer to clear all the cells and request them again.\n  redraw: function () {\n    if (this._map) {\n      this._removeAllCells();\n\n      this._update();\n    }\n\n    return this;\n  },\n  getEvents: function () {\n    var events = {\n      viewprereset: this._invalidateAll,\n      viewreset: this._resetView,\n      zoom: this._resetView,\n      moveend: this._onMoveEnd\n    };\n\n    if (!this.options.updateWhenIdle) {\n      // update cells on move, but not more often than once per given interval\n      if (!this._onMove) {\n        this._onMove = Util.throttle(this._onMoveEnd, this.options.updateInterval, this);\n      }\n\n      events.move = this._onMove;\n    }\n\n    return events;\n  },\n  // @section Extension methods\n  // Layers extending `GridLayer` shall reimplement the following method.\n  // @method createCell(coords: Object, done?: Function): HTMLElement\n  // Called only internally, must be overridden by classes extending `GridLayer`.\n  // Returns the `HTMLElement` corresponding to the given `coords`. If the `done` callback\n  // is specified, it must be called when the cell has finished loading and drawing.\n  createCell: function () {\n    return document.createElement('div');\n  },\n  removeCell: function () {},\n  reuseCell: function () {},\n  cellLeave: function () {},\n  cellEnter: function () {},\n  // @section\n  // @method getCellSize: Point\n  // Normalizes the [cellSize option](#gridlayer-cellsize) into a point. Used by the `createCell()` method.\n  getCellSize: function () {\n    var s = this.options.cellSize;\n    return s instanceof Point ? s : new Point(s, s);\n  },\n  _pruneCells: function () {\n    if (!this._map) {\n      return;\n    }\n\n    var key, cell;\n\n    for (key in this._cells) {\n      cell = this._cells[key];\n      cell.retain = cell.current;\n    }\n\n    for (key in this._cells) {\n      cell = this._cells[key];\n\n      if (cell.current && !cell.active) {\n        var coords = cell.coords;\n\n        if (!this._retainParent(coords.x, coords.y, coords.z, coords.z - 5)) {\n          this._retainChildren(coords.x, coords.y, coords.z, coords.z + 2);\n        }\n      }\n    }\n\n    for (key in this._cells) {\n      if (!this._cells[key].retain) {\n        this._removeCell(key);\n      }\n    }\n  },\n  _removeAllCells: function () {\n    for (var key in this._cells) {\n      this._removeCell(key);\n    }\n  },\n  _invalidateAll: function () {\n    this._removeAllCells();\n\n    this._cellZoom = undefined;\n  },\n  _retainParent: function (x, y, z, minZoom) {\n    var x2 = Math.floor(x / 2);\n    var y2 = Math.floor(y / 2);\n    var z2 = z - 1;\n    var coords2 = new Point(+x2, +y2);\n    coords2.z = +z2;\n\n    var key = this._cellCoordsToKey(coords2);\n\n    var cell = this._cells[key];\n\n    if (cell && cell.active) {\n      cell.retain = true;\n      return true;\n    } else if (cell && cell.loaded) {\n      cell.retain = true;\n    }\n\n    if (z2 > minZoom) {\n      return this._retainParent(x2, y2, z2, minZoom);\n    }\n\n    return false;\n  },\n  _retainChildren: function (x, y, z, maxZoom) {\n    for (var i = 2 * x; i < 2 * x + 2; i++) {\n      for (var j = 2 * y; j < 2 * y + 2; j++) {\n        var coords = new Point(i, j);\n        coords.z = z + 1;\n\n        var key = this._cellCoordsToKey(coords);\n\n        var cell = this._cells[key];\n\n        if (cell && cell.active) {\n          cell.retain = true;\n          continue;\n        } else if (cell && cell.loaded) {\n          cell.retain = true;\n        }\n\n        if (z + 1 < maxZoom) {\n          this._retainChildren(i, j, z + 1, maxZoom);\n        }\n      }\n    }\n  },\n  _resetView: function (e) {\n    var animating = e && (e.pinch || e.flyTo);\n\n    if (animating) {\n      return;\n    }\n\n    this._setView(this._map.getCenter(), this._map.getZoom(), animating, animating);\n  },\n  _setView: function (center, zoom, noPrune, noUpdate) {\n    var cellZoom = Math.round(zoom);\n\n    if (!noUpdate) {\n      this._cellZoom = cellZoom;\n\n      if (this._abortLoading) {\n        this._abortLoading();\n      }\n\n      this._resetGrid();\n\n      if (cellZoom !== undefined) {\n        this._update(center);\n      }\n\n      if (!noPrune) {\n        this._pruneCells();\n      } // Flag to prevent _updateOpacity from pruning cells during\n      // a zoom anim or a pinch gesture\n\n\n      this._noPrune = !!noPrune;\n    }\n  },\n  _resetGrid: function () {\n    var map = this._map;\n    var crs = map.options.crs;\n    var cellSize = this._cellSize = this.getCellSize();\n    var cellZoom = this._cellZoom;\n\n    var bounds = this._map.getPixelWorldBounds(this._cellZoom);\n\n    if (bounds) {\n      this._globalCellRange = this._pxBoundsToCellRange(bounds);\n    }\n\n    this._wrapX = crs.wrapLng && !this.options.noWrap && [Math.floor(map.project([0, crs.wrapLng[0]], cellZoom).x / cellSize.x), Math.ceil(map.project([0, crs.wrapLng[1]], cellZoom).x / cellSize.y)];\n    this._wrapY = crs.wrapLat && !this.options.noWrap && [Math.floor(map.project([crs.wrapLat[0], 0], cellZoom).y / cellSize.x), Math.ceil(map.project([crs.wrapLat[1], 0], cellZoom).y / cellSize.y)];\n  },\n  _onMoveEnd: function (e) {\n    var animating = e && (e.pinch || e.flyTo);\n\n    if (animating || !this._map || this._map._animatingZoom) {\n      return;\n    }\n\n    this._update();\n  },\n  _getCelldPixelBounds: function (center) {\n    var map = this._map;\n    var mapZoom = map._animatingZoom ? Math.max(map._animateToZoom, map.getZoom()) : map.getZoom();\n    var scale = map.getZoomScale(mapZoom, this._cellZoom);\n    var pixelCenter = map.project(center, this._cellZoom).floor();\n    var halfSize = map.getSize().divideBy(scale * 2);\n    return new Bounds(pixelCenter.subtract(halfSize), pixelCenter.add(halfSize));\n  },\n  // Private method to load cells in the grid's active zoom level according to map bounds\n  _update: function (center) {\n    var map = this._map;\n\n    if (!map) {\n      return;\n    }\n\n    var zoom = Math.round(map.getZoom());\n\n    if (center === undefined) {\n      center = map.getCenter();\n    }\n\n    var pixelBounds = this._getCelldPixelBounds(center);\n\n    var cellRange = this._pxBoundsToCellRange(pixelBounds);\n\n    var cellCenter = cellRange.getCenter();\n    var queue = [];\n    var margin = this.options.keepBuffer;\n    var noPruneRange = new Bounds(cellRange.getBottomLeft().subtract([margin, -margin]), cellRange.getTopRight().add([margin, -margin])); // Sanity check: panic if the cell range contains Infinity somewhere.\n\n    if (!(isFinite(cellRange.min.x) && isFinite(cellRange.min.y) && isFinite(cellRange.max.x) && isFinite(cellRange.max.y))) {\n      throw new Error('Attempted to load an infinite number of cells');\n    }\n\n    for (var key in this._cells) {\n      var c = this._cells[key].coords;\n\n      if (c.z !== this._cellZoom || !noPruneRange.contains(new Point(c.x, c.y))) {\n        this._cells[key].current = false;\n      }\n    } // _update just loads more cells. If the cell zoom level differs too much\n    // from the map's, let _setView reset levels and prune old cells.\n\n\n    if (Math.abs(zoom - this._cellZoom) > 1) {\n      this._setView(center, zoom);\n\n      return;\n    } // create a queue of coordinates to load cells from\n\n\n    for (var j = cellRange.min.y; j <= cellRange.max.y; j++) {\n      for (var i = cellRange.min.x; i <= cellRange.max.x; i++) {\n        var coords = new Point(i, j);\n        coords.z = this._cellZoom;\n\n        if (!this._isValidCell(coords)) {\n          continue;\n        }\n\n        var cell = this._cells[this._cellCoordsToKey(coords)];\n\n        if (cell) {\n          cell.current = true;\n        } else {\n          queue.push(coords);\n        }\n      }\n    } // sort cell queue to load cells in order of their distance to center\n\n\n    queue.sort(function (a, b) {\n      return a.distanceTo(cellCenter) - b.distanceTo(cellCenter);\n    });\n\n    if (queue.length !== 0) {\n      // if it's the first batch of cells to load\n      if (!this._loading) {\n        this._loading = true;\n      }\n\n      for (i = 0; i < queue.length; i++) {\n        var _key = this._cellCoordsToKey(queue[i]);\n\n        var _coords = this._keyToCellCoords(_key);\n\n        if (this._activeCells[_coords]) {\n          this._reuseCell(queue[i]);\n        } else {\n          this._createCell(queue[i]);\n        }\n      }\n    }\n  },\n  _isValidCell: function (coords) {\n    var crs = this._map.options.crs;\n\n    if (!crs.infinite) {\n      // don't load cell if it's out of bounds and not wrapped\n      var bounds = this._globalCellRange;\n\n      if (!crs.wrapLng && (coords.x < bounds.min.x || coords.x > bounds.max.x) || !crs.wrapLat && (coords.y < bounds.min.y || coords.y > bounds.max.y)) {\n        return false;\n      }\n    }\n\n    if (!this.options.bounds) {\n      return true;\n    } // don't load cell if it doesn't intersect the bounds in options\n\n\n    var cellBounds = this._cellCoordsToBounds(coords);\n\n    return latLngBounds(this.options.bounds).overlaps(cellBounds);\n  },\n  _keyToBounds: function (key) {\n    return this._cellCoordsToBounds(this._keyToCellCoords(key));\n  },\n  _cellCoordsToNwSe: function (coords) {\n    var map = this._map;\n    var cellSize = this.getCellSize();\n    var nwPoint = coords.scaleBy(cellSize);\n    var sePoint = nwPoint.add(cellSize);\n    var nw = map.unproject(nwPoint, coords.z);\n    var se = map.unproject(sePoint, coords.z);\n    return [nw, se];\n  },\n  // converts cell coordinates to its geographical bounds\n  _cellCoordsToBounds: function (coords) {\n    var bp = this._cellCoordsToNwSe(coords);\n\n    var bounds = new LatLngBounds(bp[0], bp[1]);\n\n    if (!this.options.noWrap) {\n      bounds = this._map.wrapLatLngBounds(bounds);\n    }\n\n    return bounds;\n  },\n  // converts cell coordinates to key for the cell cache\n  _cellCoordsToKey: function (coords) {\n    return coords.x + ':' + coords.y + ':' + coords.z;\n  },\n  // converts cell cache key to coordinates\n  _keyToCellCoords: function (key) {\n    var k = key.split(':');\n    var coords = new Point(+k[0], +k[1]);\n    coords.z = +k[2];\n    return coords;\n  },\n  _removeCell: function (key) {\n    var cell = this._cells[key];\n\n    if (!cell) {\n      return;\n    }\n\n    var coords = this._keyToCellCoords(key);\n\n    var wrappedCoords = this._wrapCoords(coords);\n\n    var cellBounds = this._cellCoordsToBounds(this._wrapCoords(coords));\n\n    cell.current = false;\n    delete this._cells[key];\n    this._activeCells[key] = cell;\n    this.cellLeave(cellBounds, wrappedCoords, key);\n    this.fire('cellleave', {\n      key: key,\n      coords: wrappedCoords,\n      bounds: cellBounds\n    });\n  },\n  _reuseCell: function (coords) {\n    var key = this._cellCoordsToKey(coords); // save cell in cache\n\n\n    this._cells[key] = this._activeCells[key];\n    this._cells[key].current = true;\n\n    var wrappedCoords = this._wrapCoords(coords);\n\n    var cellBounds = this._cellCoordsToBounds(this._wrapCoords(coords));\n\n    this.cellEnter(cellBounds, wrappedCoords, key);\n    this.fire('cellenter', {\n      key: key,\n      coords: wrappedCoords,\n      bounds: cellBounds\n    });\n  },\n  _createCell: function (coords) {\n    var key = this._cellCoordsToKey(coords);\n\n    var wrappedCoords = this._wrapCoords(coords);\n\n    var cellBounds = this._cellCoordsToBounds(this._wrapCoords(coords));\n\n    this.createCell(cellBounds, wrappedCoords, key);\n    this.fire('cellcreate', {\n      key: key,\n      coords: wrappedCoords,\n      bounds: cellBounds\n    }); // save cell in cache\n\n    this._cells[key] = {\n      coords: coords,\n      current: true\n    };\n    Util.requestAnimFrame(this._pruneCells, this);\n  },\n  _cellReady: function (coords, err, cell) {\n    var key = this._cellCoordsToKey(coords);\n\n    cell = this._cells[key];\n\n    if (!cell) {\n      return;\n    }\n\n    cell.loaded = +new Date();\n    cell.active = true;\n  },\n  _getCellPos: function (coords) {\n    return coords.scaleBy(this.getCellSize());\n  },\n  _wrapCoords: function (coords) {\n    var newCoords = new Point(this._wrapX ? Util.wrapNum(coords.x, this._wrapX) : coords.x, this._wrapY ? Util.wrapNum(coords.y, this._wrapY) : coords.y);\n    newCoords.z = coords.z;\n    return newCoords;\n  },\n  _pxBoundsToCellRange: function (bounds) {\n    var cellSize = this.getCellSize();\n    return new Bounds(bounds.min.unscaleBy(cellSize).floor(), bounds.max.unscaleBy(cellSize).ceil().subtract([1, 1]));\n  }\n});","map":{"version":3,"names":["LatLngBounds","toLatLngBounds","latLngBounds","Layer","Browser","Util","Point","Bounds","FeatureGrid","extend","options","cellSize","updateWhenIdle","mobile","updateInterval","noWrap","keepBuffer","initialize","setOptions","onAdd","map","_cells","_activeCells","_resetView","_update","onRemove","_removeAllCells","_cellZoom","undefined","isLoading","_loading","redraw","_map","getEvents","events","viewprereset","_invalidateAll","viewreset","zoom","moveend","_onMoveEnd","_onMove","throttle","move","createCell","document","createElement","removeCell","reuseCell","cellLeave","cellEnter","getCellSize","s","_pruneCells","key","cell","retain","current","active","coords","_retainParent","x","y","z","_retainChildren","_removeCell","minZoom","x2","Math","floor","y2","z2","coords2","_cellCoordsToKey","loaded","maxZoom","i","j","e","animating","pinch","flyTo","_setView","getCenter","getZoom","center","noPrune","noUpdate","cellZoom","round","_abortLoading","_resetGrid","_noPrune","crs","_cellSize","bounds","getPixelWorldBounds","_globalCellRange","_pxBoundsToCellRange","_wrapX","wrapLng","project","ceil","_wrapY","wrapLat","_animatingZoom","_getCelldPixelBounds","mapZoom","max","_animateToZoom","scale","getZoomScale","pixelCenter","halfSize","getSize","divideBy","subtract","add","pixelBounds","cellRange","cellCenter","queue","margin","noPruneRange","getBottomLeft","getTopRight","isFinite","min","Error","c","contains","abs","_isValidCell","push","sort","a","b","distanceTo","length","_key","_coords","_keyToCellCoords","_reuseCell","_createCell","infinite","cellBounds","_cellCoordsToBounds","overlaps","_keyToBounds","_cellCoordsToNwSe","nwPoint","scaleBy","sePoint","nw","unproject","se","bp","wrapLatLngBounds","k","split","wrappedCoords","_wrapCoords","fire","requestAnimFrame","_cellReady","err","Date","_getCellPos","newCoords","wrapNum","unscaleBy"],"sources":["C:/Users/Larix/Documents/Programmieren/ABSCHLUSS/wbs-final-box-fe/node_modules/esri-leaflet/src/Layers/FeatureLayer/FeatureGrid.js"],"sourcesContent":["import {\r\n  LatLngBounds,\r\n  toLatLngBounds as latLngBounds,\r\n  Layer,\r\n  Browser,\r\n  Util,\r\n  Point,\r\n  Bounds\r\n} from 'leaflet';\r\n\r\nexport var FeatureGrid = Layer.extend({\r\n  // @section\r\n  // @aka GridLayer options\r\n  options: {\r\n    // @option cellSize: Number|Point = 256\r\n    // Width and height of cells in the grid. Use a number if width and height are equal, or `L.point(width, height)` otherwise.\r\n    cellSize: 512,\r\n\r\n    // @option updateWhenIdle: Boolean = (depends)\r\n    // Load new cells only when panning ends.\r\n    // `true` by default on mobile browsers, in order to avoid too many requests and keep smooth navigation.\r\n    // `false` otherwise in order to display new cells _during_ panning, since it is easy to pan outside the\r\n    // [`keepBuffer`](#gridlayer-keepbuffer) option in desktop browsers.\r\n    updateWhenIdle: Browser.mobile,\r\n\r\n    // @option updateInterval: Number = 150\r\n    // Cells will not update more than once every `updateInterval` milliseconds when panning.\r\n    updateInterval: 150,\r\n\r\n    // @option noWrap: Boolean = false\r\n    // Whether the layer is wrapped around the antimeridian. If `true`, the\r\n    // GridLayer will only be displayed once at low zoom levels. Has no\r\n    // effect when the [map CRS](#map-crs) doesn't wrap around. Can be used\r\n    // in combination with [`bounds`](#gridlayer-bounds) to prevent requesting\r\n    // cells outside the CRS limits.\r\n    noWrap: false,\r\n\r\n    // @option keepBuffer: Number = 1.5\r\n    // When panning the map, keep this many rows and columns of cells before unloading them.\r\n    keepBuffer: 1.5\r\n  },\r\n\r\n  initialize: function (options) {\r\n    Util.setOptions(this, options);\r\n  },\r\n\r\n  onAdd: function (map) {\r\n    this._cells = {};\r\n    this._activeCells = {};\r\n    this._resetView();\r\n    this._update();\r\n  },\r\n\r\n  onRemove: function (map) {\r\n    this._removeAllCells();\r\n    this._cellZoom = undefined;\r\n  },\r\n\r\n  // @method isLoading: Boolean\r\n  // Returns `true` if any cell in the grid layer has not finished loading.\r\n  isLoading: function () {\r\n    return this._loading;\r\n  },\r\n\r\n  // @method redraw: this\r\n  // Causes the layer to clear all the cells and request them again.\r\n  redraw: function () {\r\n    if (this._map) {\r\n      this._removeAllCells();\r\n      this._update();\r\n    }\r\n    return this;\r\n  },\r\n\r\n  getEvents: function () {\r\n    var events = {\r\n      viewprereset: this._invalidateAll,\r\n      viewreset: this._resetView,\r\n      zoom: this._resetView,\r\n      moveend: this._onMoveEnd\r\n    };\r\n\r\n    if (!this.options.updateWhenIdle) {\r\n      // update cells on move, but not more often than once per given interval\r\n      if (!this._onMove) {\r\n        this._onMove = Util.throttle(\r\n          this._onMoveEnd,\r\n          this.options.updateInterval,\r\n          this\r\n        );\r\n      }\r\n\r\n      events.move = this._onMove;\r\n    }\r\n\r\n    return events;\r\n  },\r\n\r\n  // @section Extension methods\r\n  // Layers extending `GridLayer` shall reimplement the following method.\r\n  // @method createCell(coords: Object, done?: Function): HTMLElement\r\n  // Called only internally, must be overridden by classes extending `GridLayer`.\r\n  // Returns the `HTMLElement` corresponding to the given `coords`. If the `done` callback\r\n  // is specified, it must be called when the cell has finished loading and drawing.\r\n  createCell: function () {\r\n    return document.createElement('div');\r\n  },\r\n\r\n  removeCell: function () {\r\n\r\n  },\r\n\r\n  reuseCell: function () {\r\n\r\n  },\r\n\r\n  cellLeave: function () {\r\n\r\n  },\r\n\r\n  cellEnter: function () {\r\n\r\n  },\r\n  // @section\r\n  // @method getCellSize: Point\r\n  // Normalizes the [cellSize option](#gridlayer-cellsize) into a point. Used by the `createCell()` method.\r\n  getCellSize: function () {\r\n    var s = this.options.cellSize;\r\n    return s instanceof Point ? s : new Point(s, s);\r\n  },\r\n\r\n  _pruneCells: function () {\r\n    if (!this._map) {\r\n      return;\r\n    }\r\n\r\n    var key, cell;\r\n\r\n    for (key in this._cells) {\r\n      cell = this._cells[key];\r\n      cell.retain = cell.current;\r\n    }\r\n\r\n    for (key in this._cells) {\r\n      cell = this._cells[key];\r\n      if (cell.current && !cell.active) {\r\n        var coords = cell.coords;\r\n        if (!this._retainParent(coords.x, coords.y, coords.z, coords.z - 5)) {\r\n          this._retainChildren(coords.x, coords.y, coords.z, coords.z + 2);\r\n        }\r\n      }\r\n    }\r\n\r\n    for (key in this._cells) {\r\n      if (!this._cells[key].retain) {\r\n        this._removeCell(key);\r\n      }\r\n    }\r\n  },\r\n\r\n  _removeAllCells: function () {\r\n    for (var key in this._cells) {\r\n      this._removeCell(key);\r\n    }\r\n  },\r\n\r\n  _invalidateAll: function () {\r\n    this._removeAllCells();\r\n\r\n    this._cellZoom = undefined;\r\n  },\r\n\r\n  _retainParent: function (x, y, z, minZoom) {\r\n    var x2 = Math.floor(x / 2);\r\n    var y2 = Math.floor(y / 2);\r\n    var z2 = z - 1;\r\n    var coords2 = new Point(+x2, +y2);\r\n    coords2.z = +z2;\r\n\r\n    var key = this._cellCoordsToKey(coords2);\r\n    var cell = this._cells[key];\r\n\r\n    if (cell && cell.active) {\r\n      cell.retain = true;\r\n      return true;\r\n    } else if (cell && cell.loaded) {\r\n      cell.retain = true;\r\n    }\r\n\r\n    if (z2 > minZoom) {\r\n      return this._retainParent(x2, y2, z2, minZoom);\r\n    }\r\n\r\n    return false;\r\n  },\r\n\r\n  _retainChildren: function (x, y, z, maxZoom) {\r\n    for (var i = 2 * x; i < 2 * x + 2; i++) {\r\n      for (var j = 2 * y; j < 2 * y + 2; j++) {\r\n        var coords = new Point(i, j);\r\n        coords.z = z + 1;\r\n\r\n        var key = this._cellCoordsToKey(coords);\r\n        var cell = this._cells[key];\r\n\r\n        if (cell && cell.active) {\r\n          cell.retain = true;\r\n          continue;\r\n        } else if (cell && cell.loaded) {\r\n          cell.retain = true;\r\n        }\r\n\r\n        if (z + 1 < maxZoom) {\r\n          this._retainChildren(i, j, z + 1, maxZoom);\r\n        }\r\n      }\r\n    }\r\n  },\r\n\r\n  _resetView: function (e) {\r\n    var animating = e && (e.pinch || e.flyTo);\r\n\r\n    if (animating) {\r\n      return;\r\n    }\r\n\r\n    this._setView(\r\n      this._map.getCenter(),\r\n      this._map.getZoom(),\r\n      animating,\r\n      animating\r\n    );\r\n  },\r\n\r\n  _setView: function (center, zoom, noPrune, noUpdate) {\r\n    var cellZoom = Math.round(zoom);\r\n\r\n    if (!noUpdate) {\r\n      this._cellZoom = cellZoom;\r\n\r\n      if (this._abortLoading) {\r\n        this._abortLoading();\r\n      }\r\n\r\n      this._resetGrid();\r\n\r\n      if (cellZoom !== undefined) {\r\n        this._update(center);\r\n      }\r\n\r\n      if (!noPrune) {\r\n        this._pruneCells();\r\n      }\r\n\r\n      // Flag to prevent _updateOpacity from pruning cells during\r\n      // a zoom anim or a pinch gesture\r\n      this._noPrune = !!noPrune;\r\n    }\r\n  },\r\n\r\n  _resetGrid: function () {\r\n    var map = this._map;\r\n    var crs = map.options.crs;\r\n    var cellSize = (this._cellSize = this.getCellSize());\r\n    var cellZoom = this._cellZoom;\r\n\r\n    var bounds = this._map.getPixelWorldBounds(this._cellZoom);\r\n    if (bounds) {\r\n      this._globalCellRange = this._pxBoundsToCellRange(bounds);\r\n    }\r\n\r\n    this._wrapX = crs.wrapLng &&\r\n      !this.options.noWrap && [\r\n      Math.floor(map.project([0, crs.wrapLng[0]], cellZoom).x / cellSize.x),\r\n      Math.ceil(map.project([0, crs.wrapLng[1]], cellZoom).x / cellSize.y)\r\n    ];\r\n    this._wrapY = crs.wrapLat &&\r\n      !this.options.noWrap && [\r\n      Math.floor(map.project([crs.wrapLat[0], 0], cellZoom).y / cellSize.x),\r\n      Math.ceil(map.project([crs.wrapLat[1], 0], cellZoom).y / cellSize.y)\r\n    ];\r\n  },\r\n\r\n  _onMoveEnd: function (e) {\r\n    var animating = e && (e.pinch || e.flyTo);\r\n\r\n    if (animating || !this._map || this._map._animatingZoom) {\r\n      return;\r\n    }\r\n\r\n    this._update();\r\n  },\r\n\r\n  _getCelldPixelBounds: function (center) {\r\n    var map = this._map;\r\n    var mapZoom = map._animatingZoom\r\n      ? Math.max(map._animateToZoom, map.getZoom())\r\n      : map.getZoom();\r\n    var scale = map.getZoomScale(mapZoom, this._cellZoom);\r\n    var pixelCenter = map.project(center, this._cellZoom).floor();\r\n    var halfSize = map.getSize().divideBy(scale * 2);\r\n\r\n    return new Bounds(\r\n      pixelCenter.subtract(halfSize),\r\n      pixelCenter.add(halfSize)\r\n    );\r\n  },\r\n\r\n  // Private method to load cells in the grid's active zoom level according to map bounds\r\n  _update: function (center) {\r\n    var map = this._map;\r\n    if (!map) {\r\n      return;\r\n    }\r\n    var zoom = Math.round(map.getZoom());\r\n\r\n    if (center === undefined) {\r\n      center = map.getCenter();\r\n    }\r\n\r\n    var pixelBounds = this._getCelldPixelBounds(center);\r\n    var cellRange = this._pxBoundsToCellRange(pixelBounds);\r\n    var cellCenter = cellRange.getCenter();\r\n    var queue = [];\r\n    var margin = this.options.keepBuffer;\r\n    var noPruneRange = new Bounds(\r\n      cellRange.getBottomLeft().subtract([margin, -margin]),\r\n      cellRange.getTopRight().add([margin, -margin])\r\n    );\r\n\r\n    // Sanity check: panic if the cell range contains Infinity somewhere.\r\n    if (\r\n      !(\r\n        isFinite(cellRange.min.x) &&\r\n        isFinite(cellRange.min.y) &&\r\n        isFinite(cellRange.max.x) &&\r\n        isFinite(cellRange.max.y)\r\n      )\r\n    ) {\r\n      throw new Error('Attempted to load an infinite number of cells');\r\n    }\r\n\r\n    for (var key in this._cells) {\r\n      var c = this._cells[key].coords;\r\n      if (\r\n        c.z !== this._cellZoom ||\r\n        !noPruneRange.contains(new Point(c.x, c.y))\r\n      ) {\r\n        this._cells[key].current = false;\r\n      }\r\n    }\r\n\r\n    // _update just loads more cells. If the cell zoom level differs too much\r\n    // from the map's, let _setView reset levels and prune old cells.\r\n    if (Math.abs(zoom - this._cellZoom) > 1) {\r\n      this._setView(center, zoom);\r\n      return;\r\n    }\r\n\r\n    // create a queue of coordinates to load cells from\r\n    for (var j = cellRange.min.y; j <= cellRange.max.y; j++) {\r\n      for (var i = cellRange.min.x; i <= cellRange.max.x; i++) {\r\n        var coords = new Point(i, j);\r\n        coords.z = this._cellZoom;\r\n\r\n        if (!this._isValidCell(coords)) {\r\n          continue;\r\n        }\r\n\r\n        var cell = this._cells[this._cellCoordsToKey(coords)];\r\n        if (cell) {\r\n          cell.current = true;\r\n        } else {\r\n          queue.push(coords);\r\n        }\r\n      }\r\n    }\r\n\r\n    // sort cell queue to load cells in order of their distance to center\r\n    queue.sort(function (a, b) {\r\n      return a.distanceTo(cellCenter) - b.distanceTo(cellCenter);\r\n    });\r\n\r\n    if (queue.length !== 0) {\r\n      // if it's the first batch of cells to load\r\n      if (!this._loading) {\r\n        this._loading = true;\r\n      }\r\n\r\n      for (i = 0; i < queue.length; i++) {\r\n        var _key = this._cellCoordsToKey(queue[i]);\r\n        var _coords = this._keyToCellCoords(_key);\r\n        if (this._activeCells[_coords]) {\r\n          this._reuseCell(queue[i]);\r\n        } else {\r\n          this._createCell(queue[i]);\r\n        }\r\n      }\r\n    }\r\n  },\r\n\r\n  _isValidCell: function (coords) {\r\n    var crs = this._map.options.crs;\r\n\r\n    if (!crs.infinite) {\r\n      // don't load cell if it's out of bounds and not wrapped\r\n      var bounds = this._globalCellRange;\r\n      if (\r\n        (!crs.wrapLng &&\r\n          (coords.x < bounds.min.x || coords.x > bounds.max.x)) ||\r\n        (!crs.wrapLat && (coords.y < bounds.min.y || coords.y > bounds.max.y))\r\n      ) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    if (!this.options.bounds) {\r\n      return true;\r\n    }\r\n\r\n    // don't load cell if it doesn't intersect the bounds in options\r\n    var cellBounds = this._cellCoordsToBounds(coords);\r\n    return latLngBounds(this.options.bounds).overlaps(cellBounds);\r\n  },\r\n\r\n  _keyToBounds: function (key) {\r\n    return this._cellCoordsToBounds(this._keyToCellCoords(key));\r\n  },\r\n\r\n  _cellCoordsToNwSe: function (coords) {\r\n    var map = this._map;\r\n    var cellSize = this.getCellSize();\r\n    var nwPoint = coords.scaleBy(cellSize);\r\n    var sePoint = nwPoint.add(cellSize);\r\n    var nw = map.unproject(nwPoint, coords.z);\r\n    var se = map.unproject(sePoint, coords.z);\r\n\r\n    return [nw, se];\r\n  },\r\n\r\n  // converts cell coordinates to its geographical bounds\r\n  _cellCoordsToBounds: function (coords) {\r\n    var bp = this._cellCoordsToNwSe(coords);\r\n    var bounds = new LatLngBounds(bp[0], bp[1]);\r\n\r\n    if (!this.options.noWrap) {\r\n      bounds = this._map.wrapLatLngBounds(bounds);\r\n    }\r\n    return bounds;\r\n  },\r\n  // converts cell coordinates to key for the cell cache\r\n  _cellCoordsToKey: function (coords) {\r\n    return coords.x + ':' + coords.y + ':' + coords.z;\r\n  },\r\n\r\n  // converts cell cache key to coordinates\r\n  _keyToCellCoords: function (key) {\r\n    var k = key.split(':');\r\n    var coords = new Point(+k[0], +k[1]);\r\n\r\n    coords.z = +k[2];\r\n    return coords;\r\n  },\r\n\r\n  _removeCell: function (key) {\r\n    var cell = this._cells[key];\r\n\r\n    if (!cell) {\r\n      return;\r\n    }\r\n\r\n    var coords = this._keyToCellCoords(key);\r\n    var wrappedCoords = this._wrapCoords(coords);\r\n    var cellBounds = this._cellCoordsToBounds(this._wrapCoords(coords));\r\n\r\n    cell.current = false;\r\n\r\n    delete this._cells[key];\r\n    this._activeCells[key] = cell;\r\n\r\n    this.cellLeave(cellBounds, wrappedCoords, key);\r\n\r\n    this.fire('cellleave', {\r\n      key: key,\r\n      coords: wrappedCoords,\r\n      bounds: cellBounds\r\n    });\r\n  },\r\n\r\n  _reuseCell: function (coords) {\r\n    var key = this._cellCoordsToKey(coords);\r\n\r\n    // save cell in cache\r\n    this._cells[key] = this._activeCells[key];\r\n    this._cells[key].current = true;\r\n\r\n    var wrappedCoords = this._wrapCoords(coords);\r\n    var cellBounds = this._cellCoordsToBounds(this._wrapCoords(coords));\r\n\r\n    this.cellEnter(cellBounds, wrappedCoords, key);\r\n\r\n    this.fire('cellenter', {\r\n      key: key,\r\n      coords: wrappedCoords,\r\n      bounds: cellBounds\r\n    });\r\n  },\r\n\r\n  _createCell: function (coords) {\r\n    var key = this._cellCoordsToKey(coords);\r\n\r\n    var wrappedCoords = this._wrapCoords(coords);\r\n    var cellBounds = this._cellCoordsToBounds(this._wrapCoords(coords));\r\n\r\n    this.createCell(cellBounds, wrappedCoords, key);\r\n\r\n    this.fire('cellcreate', {\r\n      key: key,\r\n      coords: wrappedCoords,\r\n      bounds: cellBounds\r\n    });\r\n\r\n    // save cell in cache\r\n    this._cells[key] = {\r\n      coords: coords,\r\n      current: true\r\n    };\r\n\r\n    Util.requestAnimFrame(this._pruneCells, this);\r\n  },\r\n\r\n  _cellReady: function (coords, err, cell) {\r\n    var key = this._cellCoordsToKey(coords);\r\n\r\n    cell = this._cells[key];\r\n\r\n    if (!cell) {\r\n      return;\r\n    }\r\n\r\n    cell.loaded = +new Date();\r\n\r\n    cell.active = true;\r\n  },\r\n\r\n  _getCellPos: function (coords) {\r\n    return coords.scaleBy(this.getCellSize());\r\n  },\r\n\r\n  _wrapCoords: function (coords) {\r\n    var newCoords = new Point(\r\n      this._wrapX ? Util.wrapNum(coords.x, this._wrapX) : coords.x,\r\n      this._wrapY ? Util.wrapNum(coords.y, this._wrapY) : coords.y\r\n    );\r\n    newCoords.z = coords.z;\r\n    return newCoords;\r\n  },\r\n\r\n  _pxBoundsToCellRange: function (bounds) {\r\n    var cellSize = this.getCellSize();\r\n    return new Bounds(\r\n      bounds.min.unscaleBy(cellSize).floor(),\r\n      bounds.max.unscaleBy(cellSize).ceil().subtract([1, 1])\r\n    );\r\n  }\r\n});\r\n"],"mappings":"AAAA,SACEA,YADF,EAEEC,cAAc,IAAIC,YAFpB,EAGEC,KAHF,EAIEC,OAJF,EAKEC,IALF,EAMEC,KANF,EAOEC,MAPF,QAQO,SARP;AAUA,OAAO,IAAIC,WAAW,GAAGL,KAAK,CAACM,MAAN,CAAa;EACpC;EACA;EACAC,OAAO,EAAE;IACP;IACA;IACAC,QAAQ,EAAE,GAHH;IAKP;IACA;IACA;IACA;IACA;IACAC,cAAc,EAAER,OAAO,CAACS,MAVjB;IAYP;IACA;IACAC,cAAc,EAAE,GAdT;IAgBP;IACA;IACA;IACA;IACA;IACA;IACAC,MAAM,EAAE,KAtBD;IAwBP;IACA;IACAC,UAAU,EAAE;EA1BL,CAH2B;EAgCpCC,UAAU,EAAE,UAAUP,OAAV,EAAmB;IAC7BL,IAAI,CAACa,UAAL,CAAgB,IAAhB,EAAsBR,OAAtB;EACD,CAlCmC;EAoCpCS,KAAK,EAAE,UAAUC,GAAV,EAAe;IACpB,KAAKC,MAAL,GAAc,EAAd;IACA,KAAKC,YAAL,GAAoB,EAApB;;IACA,KAAKC,UAAL;;IACA,KAAKC,OAAL;EACD,CAzCmC;EA2CpCC,QAAQ,EAAE,UAAUL,GAAV,EAAe;IACvB,KAAKM,eAAL;;IACA,KAAKC,SAAL,GAAiBC,SAAjB;EACD,CA9CmC;EAgDpC;EACA;EACAC,SAAS,EAAE,YAAY;IACrB,OAAO,KAAKC,QAAZ;EACD,CApDmC;EAsDpC;EACA;EACAC,MAAM,EAAE,YAAY;IAClB,IAAI,KAAKC,IAAT,EAAe;MACb,KAAKN,eAAL;;MACA,KAAKF,OAAL;IACD;;IACD,OAAO,IAAP;EACD,CA9DmC;EAgEpCS,SAAS,EAAE,YAAY;IACrB,IAAIC,MAAM,GAAG;MACXC,YAAY,EAAE,KAAKC,cADR;MAEXC,SAAS,EAAE,KAAKd,UAFL;MAGXe,IAAI,EAAE,KAAKf,UAHA;MAIXgB,OAAO,EAAE,KAAKC;IAJH,CAAb;;IAOA,IAAI,CAAC,KAAK9B,OAAL,CAAaE,cAAlB,EAAkC;MAChC;MACA,IAAI,CAAC,KAAK6B,OAAV,EAAmB;QACjB,KAAKA,OAAL,GAAepC,IAAI,CAACqC,QAAL,CACb,KAAKF,UADQ,EAEb,KAAK9B,OAAL,CAAaI,cAFA,EAGb,IAHa,CAAf;MAKD;;MAEDoB,MAAM,CAACS,IAAP,GAAc,KAAKF,OAAnB;IACD;;IAED,OAAOP,MAAP;EACD,CAtFmC;EAwFpC;EACA;EACA;EACA;EACA;EACA;EACAU,UAAU,EAAE,YAAY;IACtB,OAAOC,QAAQ,CAACC,aAAT,CAAuB,KAAvB,CAAP;EACD,CAhGmC;EAkGpCC,UAAU,EAAE,YAAY,CAEvB,CApGmC;EAsGpCC,SAAS,EAAE,YAAY,CAEtB,CAxGmC;EA0GpCC,SAAS,EAAE,YAAY,CAEtB,CA5GmC;EA8GpCC,SAAS,EAAE,YAAY,CAEtB,CAhHmC;EAiHpC;EACA;EACA;EACAC,WAAW,EAAE,YAAY;IACvB,IAAIC,CAAC,GAAG,KAAK1C,OAAL,CAAaC,QAArB;IACA,OAAOyC,CAAC,YAAY9C,KAAb,GAAqB8C,CAArB,GAAyB,IAAI9C,KAAJ,CAAU8C,CAAV,EAAaA,CAAb,CAAhC;EACD,CAvHmC;EAyHpCC,WAAW,EAAE,YAAY;IACvB,IAAI,CAAC,KAAKrB,IAAV,EAAgB;MACd;IACD;;IAED,IAAIsB,GAAJ,EAASC,IAAT;;IAEA,KAAKD,GAAL,IAAY,KAAKjC,MAAjB,EAAyB;MACvBkC,IAAI,GAAG,KAAKlC,MAAL,CAAYiC,GAAZ,CAAP;MACAC,IAAI,CAACC,MAAL,GAAcD,IAAI,CAACE,OAAnB;IACD;;IAED,KAAKH,GAAL,IAAY,KAAKjC,MAAjB,EAAyB;MACvBkC,IAAI,GAAG,KAAKlC,MAAL,CAAYiC,GAAZ,CAAP;;MACA,IAAIC,IAAI,CAACE,OAAL,IAAgB,CAACF,IAAI,CAACG,MAA1B,EAAkC;QAChC,IAAIC,MAAM,GAAGJ,IAAI,CAACI,MAAlB;;QACA,IAAI,CAAC,KAAKC,aAAL,CAAmBD,MAAM,CAACE,CAA1B,EAA6BF,MAAM,CAACG,CAApC,EAAuCH,MAAM,CAACI,CAA9C,EAAiDJ,MAAM,CAACI,CAAP,GAAW,CAA5D,CAAL,EAAqE;UACnE,KAAKC,eAAL,CAAqBL,MAAM,CAACE,CAA5B,EAA+BF,MAAM,CAACG,CAAtC,EAAyCH,MAAM,CAACI,CAAhD,EAAmDJ,MAAM,CAACI,CAAP,GAAW,CAA9D;QACD;MACF;IACF;;IAED,KAAKT,GAAL,IAAY,KAAKjC,MAAjB,EAAyB;MACvB,IAAI,CAAC,KAAKA,MAAL,CAAYiC,GAAZ,EAAiBE,MAAtB,EAA8B;QAC5B,KAAKS,WAAL,CAAiBX,GAAjB;MACD;IACF;EACF,CApJmC;EAsJpC5B,eAAe,EAAE,YAAY;IAC3B,KAAK,IAAI4B,GAAT,IAAgB,KAAKjC,MAArB,EAA6B;MAC3B,KAAK4C,WAAL,CAAiBX,GAAjB;IACD;EACF,CA1JmC;EA4JpClB,cAAc,EAAE,YAAY;IAC1B,KAAKV,eAAL;;IAEA,KAAKC,SAAL,GAAiBC,SAAjB;EACD,CAhKmC;EAkKpCgC,aAAa,EAAE,UAAUC,CAAV,EAAaC,CAAb,EAAgBC,CAAhB,EAAmBG,OAAnB,EAA4B;IACzC,IAAIC,EAAE,GAAGC,IAAI,CAACC,KAAL,CAAWR,CAAC,GAAG,CAAf,CAAT;IACA,IAAIS,EAAE,GAAGF,IAAI,CAACC,KAAL,CAAWP,CAAC,GAAG,CAAf,CAAT;IACA,IAAIS,EAAE,GAAGR,CAAC,GAAG,CAAb;IACA,IAAIS,OAAO,GAAG,IAAIlE,KAAJ,CAAU,CAAC6D,EAAX,EAAe,CAACG,EAAhB,CAAd;IACAE,OAAO,CAACT,CAAR,GAAY,CAACQ,EAAb;;IAEA,IAAIjB,GAAG,GAAG,KAAKmB,gBAAL,CAAsBD,OAAtB,CAAV;;IACA,IAAIjB,IAAI,GAAG,KAAKlC,MAAL,CAAYiC,GAAZ,CAAX;;IAEA,IAAIC,IAAI,IAAIA,IAAI,CAACG,MAAjB,EAAyB;MACvBH,IAAI,CAACC,MAAL,GAAc,IAAd;MACA,OAAO,IAAP;IACD,CAHD,MAGO,IAAID,IAAI,IAAIA,IAAI,CAACmB,MAAjB,EAAyB;MAC9BnB,IAAI,CAACC,MAAL,GAAc,IAAd;IACD;;IAED,IAAIe,EAAE,GAAGL,OAAT,EAAkB;MAChB,OAAO,KAAKN,aAAL,CAAmBO,EAAnB,EAAuBG,EAAvB,EAA2BC,EAA3B,EAA+BL,OAA/B,CAAP;IACD;;IAED,OAAO,KAAP;EACD,CAxLmC;EA0LpCF,eAAe,EAAE,UAAUH,CAAV,EAAaC,CAAb,EAAgBC,CAAhB,EAAmBY,OAAnB,EAA4B;IAC3C,KAAK,IAAIC,CAAC,GAAG,IAAIf,CAAjB,EAAoBe,CAAC,GAAG,IAAIf,CAAJ,GAAQ,CAAhC,EAAmCe,CAAC,EAApC,EAAwC;MACtC,KAAK,IAAIC,CAAC,GAAG,IAAIf,CAAjB,EAAoBe,CAAC,GAAG,IAAIf,CAAJ,GAAQ,CAAhC,EAAmCe,CAAC,EAApC,EAAwC;QACtC,IAAIlB,MAAM,GAAG,IAAIrD,KAAJ,CAAUsE,CAAV,EAAaC,CAAb,CAAb;QACAlB,MAAM,CAACI,CAAP,GAAWA,CAAC,GAAG,CAAf;;QAEA,IAAIT,GAAG,GAAG,KAAKmB,gBAAL,CAAsBd,MAAtB,CAAV;;QACA,IAAIJ,IAAI,GAAG,KAAKlC,MAAL,CAAYiC,GAAZ,CAAX;;QAEA,IAAIC,IAAI,IAAIA,IAAI,CAACG,MAAjB,EAAyB;UACvBH,IAAI,CAACC,MAAL,GAAc,IAAd;UACA;QACD,CAHD,MAGO,IAAID,IAAI,IAAIA,IAAI,CAACmB,MAAjB,EAAyB;UAC9BnB,IAAI,CAACC,MAAL,GAAc,IAAd;QACD;;QAED,IAAIO,CAAC,GAAG,CAAJ,GAAQY,OAAZ,EAAqB;UACnB,KAAKX,eAAL,CAAqBY,CAArB,EAAwBC,CAAxB,EAA2Bd,CAAC,GAAG,CAA/B,EAAkCY,OAAlC;QACD;MACF;IACF;EACF,CA/MmC;EAiNpCpD,UAAU,EAAE,UAAUuD,CAAV,EAAa;IACvB,IAAIC,SAAS,GAAGD,CAAC,KAAKA,CAAC,CAACE,KAAF,IAAWF,CAAC,CAACG,KAAlB,CAAjB;;IAEA,IAAIF,SAAJ,EAAe;MACb;IACD;;IAED,KAAKG,QAAL,CACE,KAAKlD,IAAL,CAAUmD,SAAV,EADF,EAEE,KAAKnD,IAAL,CAAUoD,OAAV,EAFF,EAGEL,SAHF,EAIEA,SAJF;EAMD,CA9NmC;EAgOpCG,QAAQ,EAAE,UAAUG,MAAV,EAAkB/C,IAAlB,EAAwBgD,OAAxB,EAAiCC,QAAjC,EAA2C;IACnD,IAAIC,QAAQ,GAAGpB,IAAI,CAACqB,KAAL,CAAWnD,IAAX,CAAf;;IAEA,IAAI,CAACiD,QAAL,EAAe;MACb,KAAK5D,SAAL,GAAiB6D,QAAjB;;MAEA,IAAI,KAAKE,aAAT,EAAwB;QACtB,KAAKA,aAAL;MACD;;MAED,KAAKC,UAAL;;MAEA,IAAIH,QAAQ,KAAK5D,SAAjB,EAA4B;QAC1B,KAAKJ,OAAL,CAAa6D,MAAb;MACD;;MAED,IAAI,CAACC,OAAL,EAAc;QACZ,KAAKjC,WAAL;MACD,CAfY,CAiBb;MACA;;;MACA,KAAKuC,QAAL,GAAgB,CAAC,CAACN,OAAlB;IACD;EACF,CAxPmC;EA0PpCK,UAAU,EAAE,YAAY;IACtB,IAAIvE,GAAG,GAAG,KAAKY,IAAf;IACA,IAAI6D,GAAG,GAAGzE,GAAG,CAACV,OAAJ,CAAYmF,GAAtB;IACA,IAAIlF,QAAQ,GAAI,KAAKmF,SAAL,GAAiB,KAAK3C,WAAL,EAAjC;IACA,IAAIqC,QAAQ,GAAG,KAAK7D,SAApB;;IAEA,IAAIoE,MAAM,GAAG,KAAK/D,IAAL,CAAUgE,mBAAV,CAA8B,KAAKrE,SAAnC,CAAb;;IACA,IAAIoE,MAAJ,EAAY;MACV,KAAKE,gBAAL,GAAwB,KAAKC,oBAAL,CAA0BH,MAA1B,CAAxB;IACD;;IAED,KAAKI,MAAL,GAAcN,GAAG,CAACO,OAAJ,IACZ,CAAC,KAAK1F,OAAL,CAAaK,MADF,IACY,CACxBqD,IAAI,CAACC,KAAL,CAAWjD,GAAG,CAACiF,OAAJ,CAAY,CAAC,CAAD,EAAIR,GAAG,CAACO,OAAJ,CAAY,CAAZ,CAAJ,CAAZ,EAAiCZ,QAAjC,EAA2C3B,CAA3C,GAA+ClD,QAAQ,CAACkD,CAAnE,CADwB,EAExBO,IAAI,CAACkC,IAAL,CAAUlF,GAAG,CAACiF,OAAJ,CAAY,CAAC,CAAD,EAAIR,GAAG,CAACO,OAAJ,CAAY,CAAZ,CAAJ,CAAZ,EAAiCZ,QAAjC,EAA2C3B,CAA3C,GAA+ClD,QAAQ,CAACmD,CAAlE,CAFwB,CAD1B;IAKA,KAAKyC,MAAL,GAAcV,GAAG,CAACW,OAAJ,IACZ,CAAC,KAAK9F,OAAL,CAAaK,MADF,IACY,CACxBqD,IAAI,CAACC,KAAL,CAAWjD,GAAG,CAACiF,OAAJ,CAAY,CAACR,GAAG,CAACW,OAAJ,CAAY,CAAZ,CAAD,EAAiB,CAAjB,CAAZ,EAAiChB,QAAjC,EAA2C1B,CAA3C,GAA+CnD,QAAQ,CAACkD,CAAnE,CADwB,EAExBO,IAAI,CAACkC,IAAL,CAAUlF,GAAG,CAACiF,OAAJ,CAAY,CAACR,GAAG,CAACW,OAAJ,CAAY,CAAZ,CAAD,EAAiB,CAAjB,CAAZ,EAAiChB,QAAjC,EAA2C1B,CAA3C,GAA+CnD,QAAQ,CAACmD,CAAlE,CAFwB,CAD1B;EAKD,CA/QmC;EAiRpCtB,UAAU,EAAE,UAAUsC,CAAV,EAAa;IACvB,IAAIC,SAAS,GAAGD,CAAC,KAAKA,CAAC,CAACE,KAAF,IAAWF,CAAC,CAACG,KAAlB,CAAjB;;IAEA,IAAIF,SAAS,IAAI,CAAC,KAAK/C,IAAnB,IAA2B,KAAKA,IAAL,CAAUyE,cAAzC,EAAyD;MACvD;IACD;;IAED,KAAKjF,OAAL;EACD,CAzRmC;EA2RpCkF,oBAAoB,EAAE,UAAUrB,MAAV,EAAkB;IACtC,IAAIjE,GAAG,GAAG,KAAKY,IAAf;IACA,IAAI2E,OAAO,GAAGvF,GAAG,CAACqF,cAAJ,GACVrC,IAAI,CAACwC,GAAL,CAASxF,GAAG,CAACyF,cAAb,EAA6BzF,GAAG,CAACgE,OAAJ,EAA7B,CADU,GAEVhE,GAAG,CAACgE,OAAJ,EAFJ;IAGA,IAAI0B,KAAK,GAAG1F,GAAG,CAAC2F,YAAJ,CAAiBJ,OAAjB,EAA0B,KAAKhF,SAA/B,CAAZ;IACA,IAAIqF,WAAW,GAAG5F,GAAG,CAACiF,OAAJ,CAAYhB,MAAZ,EAAoB,KAAK1D,SAAzB,EAAoC0C,KAApC,EAAlB;IACA,IAAI4C,QAAQ,GAAG7F,GAAG,CAAC8F,OAAJ,GAAcC,QAAd,CAAuBL,KAAK,GAAG,CAA/B,CAAf;IAEA,OAAO,IAAIvG,MAAJ,CACLyG,WAAW,CAACI,QAAZ,CAAqBH,QAArB,CADK,EAELD,WAAW,CAACK,GAAZ,CAAgBJ,QAAhB,CAFK,CAAP;EAID,CAxSmC;EA0SpC;EACAzF,OAAO,EAAE,UAAU6D,MAAV,EAAkB;IACzB,IAAIjE,GAAG,GAAG,KAAKY,IAAf;;IACA,IAAI,CAACZ,GAAL,EAAU;MACR;IACD;;IACD,IAAIkB,IAAI,GAAG8B,IAAI,CAACqB,KAAL,CAAWrE,GAAG,CAACgE,OAAJ,EAAX,CAAX;;IAEA,IAAIC,MAAM,KAAKzD,SAAf,EAA0B;MACxByD,MAAM,GAAGjE,GAAG,CAAC+D,SAAJ,EAAT;IACD;;IAED,IAAImC,WAAW,GAAG,KAAKZ,oBAAL,CAA0BrB,MAA1B,CAAlB;;IACA,IAAIkC,SAAS,GAAG,KAAKrB,oBAAL,CAA0BoB,WAA1B,CAAhB;;IACA,IAAIE,UAAU,GAAGD,SAAS,CAACpC,SAAV,EAAjB;IACA,IAAIsC,KAAK,GAAG,EAAZ;IACA,IAAIC,MAAM,GAAG,KAAKhH,OAAL,CAAaM,UAA1B;IACA,IAAI2G,YAAY,GAAG,IAAIpH,MAAJ,CACjBgH,SAAS,CAACK,aAAV,GAA0BR,QAA1B,CAAmC,CAACM,MAAD,EAAS,CAACA,MAAV,CAAnC,CADiB,EAEjBH,SAAS,CAACM,WAAV,GAAwBR,GAAxB,CAA4B,CAACK,MAAD,EAAS,CAACA,MAAV,CAA5B,CAFiB,CAAnB,CAhByB,CAqBzB;;IACA,IACE,EACEI,QAAQ,CAACP,SAAS,CAACQ,GAAV,CAAclE,CAAf,CAAR,IACAiE,QAAQ,CAACP,SAAS,CAACQ,GAAV,CAAcjE,CAAf,CADR,IAEAgE,QAAQ,CAACP,SAAS,CAACX,GAAV,CAAc/C,CAAf,CAFR,IAGAiE,QAAQ,CAACP,SAAS,CAACX,GAAV,CAAc9C,CAAf,CAJV,CADF,EAOE;MACA,MAAM,IAAIkE,KAAJ,CAAU,+CAAV,CAAN;IACD;;IAED,KAAK,IAAI1E,GAAT,IAAgB,KAAKjC,MAArB,EAA6B;MAC3B,IAAI4G,CAAC,GAAG,KAAK5G,MAAL,CAAYiC,GAAZ,EAAiBK,MAAzB;;MACA,IACEsE,CAAC,CAAClE,CAAF,KAAQ,KAAKpC,SAAb,IACA,CAACgG,YAAY,CAACO,QAAb,CAAsB,IAAI5H,KAAJ,CAAU2H,CAAC,CAACpE,CAAZ,EAAeoE,CAAC,CAACnE,CAAjB,CAAtB,CAFH,EAGE;QACA,KAAKzC,MAAL,CAAYiC,GAAZ,EAAiBG,OAAjB,GAA2B,KAA3B;MACD;IACF,CAzCwB,CA2CzB;IACA;;;IACA,IAAIW,IAAI,CAAC+D,GAAL,CAAS7F,IAAI,GAAG,KAAKX,SAArB,IAAkC,CAAtC,EAAyC;MACvC,KAAKuD,QAAL,CAAcG,MAAd,EAAsB/C,IAAtB;;MACA;IACD,CAhDwB,CAkDzB;;;IACA,KAAK,IAAIuC,CAAC,GAAG0C,SAAS,CAACQ,GAAV,CAAcjE,CAA3B,EAA8Be,CAAC,IAAI0C,SAAS,CAACX,GAAV,CAAc9C,CAAjD,EAAoDe,CAAC,EAArD,EAAyD;MACvD,KAAK,IAAID,CAAC,GAAG2C,SAAS,CAACQ,GAAV,CAAclE,CAA3B,EAA8Be,CAAC,IAAI2C,SAAS,CAACX,GAAV,CAAc/C,CAAjD,EAAoDe,CAAC,EAArD,EAAyD;QACvD,IAAIjB,MAAM,GAAG,IAAIrD,KAAJ,CAAUsE,CAAV,EAAaC,CAAb,CAAb;QACAlB,MAAM,CAACI,CAAP,GAAW,KAAKpC,SAAhB;;QAEA,IAAI,CAAC,KAAKyG,YAAL,CAAkBzE,MAAlB,CAAL,EAAgC;UAC9B;QACD;;QAED,IAAIJ,IAAI,GAAG,KAAKlC,MAAL,CAAY,KAAKoD,gBAAL,CAAsBd,MAAtB,CAAZ,CAAX;;QACA,IAAIJ,IAAJ,EAAU;UACRA,IAAI,CAACE,OAAL,GAAe,IAAf;QACD,CAFD,MAEO;UACLgE,KAAK,CAACY,IAAN,CAAW1E,MAAX;QACD;MACF;IACF,CAnEwB,CAqEzB;;;IACA8D,KAAK,CAACa,IAAN,CAAW,UAAUC,CAAV,EAAaC,CAAb,EAAgB;MACzB,OAAOD,CAAC,CAACE,UAAF,CAAajB,UAAb,IAA2BgB,CAAC,CAACC,UAAF,CAAajB,UAAb,CAAlC;IACD,CAFD;;IAIA,IAAIC,KAAK,CAACiB,MAAN,KAAiB,CAArB,EAAwB;MACtB;MACA,IAAI,CAAC,KAAK5G,QAAV,EAAoB;QAClB,KAAKA,QAAL,GAAgB,IAAhB;MACD;;MAED,KAAK8C,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAG6C,KAAK,CAACiB,MAAtB,EAA8B9D,CAAC,EAA/B,EAAmC;QACjC,IAAI+D,IAAI,GAAG,KAAKlE,gBAAL,CAAsBgD,KAAK,CAAC7C,CAAD,CAA3B,CAAX;;QACA,IAAIgE,OAAO,GAAG,KAAKC,gBAAL,CAAsBF,IAAtB,CAAd;;QACA,IAAI,KAAKrH,YAAL,CAAkBsH,OAAlB,CAAJ,EAAgC;UAC9B,KAAKE,UAAL,CAAgBrB,KAAK,CAAC7C,CAAD,CAArB;QACD,CAFD,MAEO;UACL,KAAKmE,WAAL,CAAiBtB,KAAK,CAAC7C,CAAD,CAAtB;QACD;MACF;IACF;EACF,CArYmC;EAuYpCwD,YAAY,EAAE,UAAUzE,MAAV,EAAkB;IAC9B,IAAIkC,GAAG,GAAG,KAAK7D,IAAL,CAAUtB,OAAV,CAAkBmF,GAA5B;;IAEA,IAAI,CAACA,GAAG,CAACmD,QAAT,EAAmB;MACjB;MACA,IAAIjD,MAAM,GAAG,KAAKE,gBAAlB;;MACA,IACG,CAACJ,GAAG,CAACO,OAAL,KACEzC,MAAM,CAACE,CAAP,GAAWkC,MAAM,CAACgC,GAAP,CAAWlE,CAAtB,IAA2BF,MAAM,CAACE,CAAP,GAAWkC,MAAM,CAACa,GAAP,CAAW/C,CADnD,CAAD,IAEC,CAACgC,GAAG,CAACW,OAAL,KAAiB7C,MAAM,CAACG,CAAP,GAAWiC,MAAM,CAACgC,GAAP,CAAWjE,CAAtB,IAA2BH,MAAM,CAACG,CAAP,GAAWiC,MAAM,CAACa,GAAP,CAAW9C,CAAlE,CAHH,EAIE;QACA,OAAO,KAAP;MACD;IACF;;IAED,IAAI,CAAC,KAAKpD,OAAL,CAAaqF,MAAlB,EAA0B;MACxB,OAAO,IAAP;IACD,CAjB6B,CAmB9B;;;IACA,IAAIkD,UAAU,GAAG,KAAKC,mBAAL,CAAyBvF,MAAzB,CAAjB;;IACA,OAAOzD,YAAY,CAAC,KAAKQ,OAAL,CAAaqF,MAAd,CAAZ,CAAkCoD,QAAlC,CAA2CF,UAA3C,CAAP;EACD,CA7ZmC;EA+ZpCG,YAAY,EAAE,UAAU9F,GAAV,EAAe;IAC3B,OAAO,KAAK4F,mBAAL,CAAyB,KAAKL,gBAAL,CAAsBvF,GAAtB,CAAzB,CAAP;EACD,CAjamC;EAmapC+F,iBAAiB,EAAE,UAAU1F,MAAV,EAAkB;IACnC,IAAIvC,GAAG,GAAG,KAAKY,IAAf;IACA,IAAIrB,QAAQ,GAAG,KAAKwC,WAAL,EAAf;IACA,IAAImG,OAAO,GAAG3F,MAAM,CAAC4F,OAAP,CAAe5I,QAAf,CAAd;IACA,IAAI6I,OAAO,GAAGF,OAAO,CAACjC,GAAR,CAAY1G,QAAZ,CAAd;IACA,IAAI8I,EAAE,GAAGrI,GAAG,CAACsI,SAAJ,CAAcJ,OAAd,EAAuB3F,MAAM,CAACI,CAA9B,CAAT;IACA,IAAI4F,EAAE,GAAGvI,GAAG,CAACsI,SAAJ,CAAcF,OAAd,EAAuB7F,MAAM,CAACI,CAA9B,CAAT;IAEA,OAAO,CAAC0F,EAAD,EAAKE,EAAL,CAAP;EACD,CA5amC;EA8apC;EACAT,mBAAmB,EAAE,UAAUvF,MAAV,EAAkB;IACrC,IAAIiG,EAAE,GAAG,KAAKP,iBAAL,CAAuB1F,MAAvB,CAAT;;IACA,IAAIoC,MAAM,GAAG,IAAI/F,YAAJ,CAAiB4J,EAAE,CAAC,CAAD,CAAnB,EAAwBA,EAAE,CAAC,CAAD,CAA1B,CAAb;;IAEA,IAAI,CAAC,KAAKlJ,OAAL,CAAaK,MAAlB,EAA0B;MACxBgF,MAAM,GAAG,KAAK/D,IAAL,CAAU6H,gBAAV,CAA2B9D,MAA3B,CAAT;IACD;;IACD,OAAOA,MAAP;EACD,CAvbmC;EAwbpC;EACAtB,gBAAgB,EAAE,UAAUd,MAAV,EAAkB;IAClC,OAAOA,MAAM,CAACE,CAAP,GAAW,GAAX,GAAiBF,MAAM,CAACG,CAAxB,GAA4B,GAA5B,GAAkCH,MAAM,CAACI,CAAhD;EACD,CA3bmC;EA6bpC;EACA8E,gBAAgB,EAAE,UAAUvF,GAAV,EAAe;IAC/B,IAAIwG,CAAC,GAAGxG,GAAG,CAACyG,KAAJ,CAAU,GAAV,CAAR;IACA,IAAIpG,MAAM,GAAG,IAAIrD,KAAJ,CAAU,CAACwJ,CAAC,CAAC,CAAD,CAAZ,EAAiB,CAACA,CAAC,CAAC,CAAD,CAAnB,CAAb;IAEAnG,MAAM,CAACI,CAAP,GAAW,CAAC+F,CAAC,CAAC,CAAD,CAAb;IACA,OAAOnG,MAAP;EACD,CApcmC;EAscpCM,WAAW,EAAE,UAAUX,GAAV,EAAe;IAC1B,IAAIC,IAAI,GAAG,KAAKlC,MAAL,CAAYiC,GAAZ,CAAX;;IAEA,IAAI,CAACC,IAAL,EAAW;MACT;IACD;;IAED,IAAII,MAAM,GAAG,KAAKkF,gBAAL,CAAsBvF,GAAtB,CAAb;;IACA,IAAI0G,aAAa,GAAG,KAAKC,WAAL,CAAiBtG,MAAjB,CAApB;;IACA,IAAIsF,UAAU,GAAG,KAAKC,mBAAL,CAAyB,KAAKe,WAAL,CAAiBtG,MAAjB,CAAzB,CAAjB;;IAEAJ,IAAI,CAACE,OAAL,GAAe,KAAf;IAEA,OAAO,KAAKpC,MAAL,CAAYiC,GAAZ,CAAP;IACA,KAAKhC,YAAL,CAAkBgC,GAAlB,IAAyBC,IAAzB;IAEA,KAAKN,SAAL,CAAegG,UAAf,EAA2Be,aAA3B,EAA0C1G,GAA1C;IAEA,KAAK4G,IAAL,CAAU,WAAV,EAAuB;MACrB5G,GAAG,EAAEA,GADgB;MAErBK,MAAM,EAAEqG,aAFa;MAGrBjE,MAAM,EAAEkD;IAHa,CAAvB;EAKD,CA7dmC;EA+dpCH,UAAU,EAAE,UAAUnF,MAAV,EAAkB;IAC5B,IAAIL,GAAG,GAAG,KAAKmB,gBAAL,CAAsBd,MAAtB,CAAV,CAD4B,CAG5B;;;IACA,KAAKtC,MAAL,CAAYiC,GAAZ,IAAmB,KAAKhC,YAAL,CAAkBgC,GAAlB,CAAnB;IACA,KAAKjC,MAAL,CAAYiC,GAAZ,EAAiBG,OAAjB,GAA2B,IAA3B;;IAEA,IAAIuG,aAAa,GAAG,KAAKC,WAAL,CAAiBtG,MAAjB,CAApB;;IACA,IAAIsF,UAAU,GAAG,KAAKC,mBAAL,CAAyB,KAAKe,WAAL,CAAiBtG,MAAjB,CAAzB,CAAjB;;IAEA,KAAKT,SAAL,CAAe+F,UAAf,EAA2Be,aAA3B,EAA0C1G,GAA1C;IAEA,KAAK4G,IAAL,CAAU,WAAV,EAAuB;MACrB5G,GAAG,EAAEA,GADgB;MAErBK,MAAM,EAAEqG,aAFa;MAGrBjE,MAAM,EAAEkD;IAHa,CAAvB;EAKD,CAhfmC;EAkfpCF,WAAW,EAAE,UAAUpF,MAAV,EAAkB;IAC7B,IAAIL,GAAG,GAAG,KAAKmB,gBAAL,CAAsBd,MAAtB,CAAV;;IAEA,IAAIqG,aAAa,GAAG,KAAKC,WAAL,CAAiBtG,MAAjB,CAApB;;IACA,IAAIsF,UAAU,GAAG,KAAKC,mBAAL,CAAyB,KAAKe,WAAL,CAAiBtG,MAAjB,CAAzB,CAAjB;;IAEA,KAAKf,UAAL,CAAgBqG,UAAhB,EAA4Be,aAA5B,EAA2C1G,GAA3C;IAEA,KAAK4G,IAAL,CAAU,YAAV,EAAwB;MACtB5G,GAAG,EAAEA,GADiB;MAEtBK,MAAM,EAAEqG,aAFc;MAGtBjE,MAAM,EAAEkD;IAHc,CAAxB,EAR6B,CAc7B;;IACA,KAAK5H,MAAL,CAAYiC,GAAZ,IAAmB;MACjBK,MAAM,EAAEA,MADS;MAEjBF,OAAO,EAAE;IAFQ,CAAnB;IAKApD,IAAI,CAAC8J,gBAAL,CAAsB,KAAK9G,WAA3B,EAAwC,IAAxC;EACD,CAvgBmC;EAygBpC+G,UAAU,EAAE,UAAUzG,MAAV,EAAkB0G,GAAlB,EAAuB9G,IAAvB,EAA6B;IACvC,IAAID,GAAG,GAAG,KAAKmB,gBAAL,CAAsBd,MAAtB,CAAV;;IAEAJ,IAAI,GAAG,KAAKlC,MAAL,CAAYiC,GAAZ,CAAP;;IAEA,IAAI,CAACC,IAAL,EAAW;MACT;IACD;;IAEDA,IAAI,CAACmB,MAAL,GAAc,CAAC,IAAI4F,IAAJ,EAAf;IAEA/G,IAAI,CAACG,MAAL,GAAc,IAAd;EACD,CArhBmC;EAuhBpC6G,WAAW,EAAE,UAAU5G,MAAV,EAAkB;IAC7B,OAAOA,MAAM,CAAC4F,OAAP,CAAe,KAAKpG,WAAL,EAAf,CAAP;EACD,CAzhBmC;EA2hBpC8G,WAAW,EAAE,UAAUtG,MAAV,EAAkB;IAC7B,IAAI6G,SAAS,GAAG,IAAIlK,KAAJ,CACd,KAAK6F,MAAL,GAAc9F,IAAI,CAACoK,OAAL,CAAa9G,MAAM,CAACE,CAApB,EAAuB,KAAKsC,MAA5B,CAAd,GAAoDxC,MAAM,CAACE,CAD7C,EAEd,KAAK0C,MAAL,GAAclG,IAAI,CAACoK,OAAL,CAAa9G,MAAM,CAACG,CAApB,EAAuB,KAAKyC,MAA5B,CAAd,GAAoD5C,MAAM,CAACG,CAF7C,CAAhB;IAIA0G,SAAS,CAACzG,CAAV,GAAcJ,MAAM,CAACI,CAArB;IACA,OAAOyG,SAAP;EACD,CAliBmC;EAoiBpCtE,oBAAoB,EAAE,UAAUH,MAAV,EAAkB;IACtC,IAAIpF,QAAQ,GAAG,KAAKwC,WAAL,EAAf;IACA,OAAO,IAAI5C,MAAJ,CACLwF,MAAM,CAACgC,GAAP,CAAW2C,SAAX,CAAqB/J,QAArB,EAA+B0D,KAA/B,EADK,EAEL0B,MAAM,CAACa,GAAP,CAAW8D,SAAX,CAAqB/J,QAArB,EAA+B2F,IAA/B,GAAsCc,QAAtC,CAA+C,CAAC,CAAD,EAAI,CAAJ,CAA/C,CAFK,CAAP;EAID;AA1iBmC,CAAb,CAAlB"},"metadata":{},"sourceType":"module"}